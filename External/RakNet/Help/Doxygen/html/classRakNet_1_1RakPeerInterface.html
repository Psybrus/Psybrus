<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>RakNet: RakNet::RakPeerInterface Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceRakNet.html">RakNet</a>::<a class="el" href="classRakNet_1_1RakPeerInterface.html">RakPeerInterface</a>
  </div>
</div>
<div class="contents">
<h1>RakNet::RakPeerInterface Class Reference</h1><!-- doxytag: class="RakNet::RakPeerInterface" -->The main interface for network communications.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;RakPeerInterface.h&gt;</code>
<p>
<div class="dynheader">
Inheritance diagram for RakNet::RakPeerInterface:</div>
<div class="dynsection">

<p><center><img src="classRakNet_1_1RakPeerInterface.png" usemap="#RakNet::RakPeerInterface_map" border="0" alt=""></center>
<map name="RakNet::RakPeerInterface_map">
<area href="classRakNet_1_1RakPeer.html" alt="RakNet::RakPeer" shape="rect" coords="0,56,156,80">
</map>
</div>

<p>
<a href="classRakNet_1_1RakPeerInterface-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="154354ae29d11ac06ef34bd64a8dd6aa"></a><!-- doxytag: member="RakNet::RakPeerInterface::~RakPeerInterface" ref="154354ae29d11ac06ef34bd64a8dd6aa" args="()" -->
virtual&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#154354ae29d11ac06ef34bd64a8dd6aa">~RakPeerInterface</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Destructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual StartupResult&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#3c8c414844a87707c28cdf35f41a5f00">Startup</a> (unsigned short maxConnections, <a class="el" href="structRakNet_1_1SocketDescriptor.html">SocketDescriptor</a> *socketDescriptors, unsigned socketDescriptorCount, int threadPriority=-99999)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Starts the network threads, opens the listen port.  <a href="#3c8c414844a87707c28cdf35f41a5f00"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#b5389821efb5d09470f8429925766eb3">InitializeSecurity</a> (const char *publicKey, const char *privateKey, bool bRequireClientKey=false)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#ab566dbe8f666dfed108aaaabc7a0ca6">DisableSecurity</a> (void)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#5ba3e8713e5d7b150ed393eced79675d">AddToSecurityExceptionList</a> (const char *ip)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#8eba6b20dcba02453d1ed2ad77499f7d">RemoveFromSecurityExceptionList</a> (const char *ip)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#2672cee4147e50818769e3573fb5c459">IsInSecurityExceptionList</a> (const char *ip)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#1f279ee0d3578de483126f6cfef282f4">SetMaximumIncomingConnections</a> (unsigned short numberAllowed)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#39ae7c5a36a3049f34ac7fc0ad9d9478">GetMaximumIncomingConnections</a> (void) const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#88611e451f6f6e0d5f7cb00ce5bcabf9">NumberOfConnections</a> (void) const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#d18a28a99420006d020125eea1ded4ed">SetIncomingPassword</a> (const char *passwordData, int passwordDataLength)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#8b5026f40cf8e6f307e2d3ac82970a30">GetIncomingPassword</a> (char *passwordData, int *passwordDataLength)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ConnectionAttemptResult&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#451dd5d225277fe5806d3d700551fb76">Connect</a> (const char *host, unsigned short remotePort, const char *passwordData, int passwordDataLength, <a class="el" href="structRakNet_1_1PublicKey.html">PublicKey</a> *publicKey=0, unsigned connectionSocketIndex=0, unsigned sendConnectionAttemptCount=12, unsigned timeBetweenSendConnectionAttemptsMS=500, RakNet::TimeMS timeoutTime=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect to the specified host (ip or domain name) and server port. Calling Connect and not calling SetMaximumIncomingConnections acts as a dedicated client. Calling both acts as a true peer. This is a non-blocking connection. You know the connection is successful when <a class="el" href="classRakNet_1_1RakPeerInterface.html#33744f90a202b8e57d6a825d6af080cc">GetConnectionState()</a> returns IS_CONNECTED or <a class="el" href="classRakNet_1_1RakPeerInterface.html#1c50453d9dee600920aeabd62ad7c119">Receive()</a> gets a message with the type identifier ID_CONNECTION_REQUEST_ACCEPTED. If the connection is not successful, such as a rejected connection or no response then neither of these things will happen.  <a href="#451dd5d225277fe5806d3d700551fb76"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual ConnectionAttemptResult&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#453c82a09aa5c5c8a26f3c9695e589d8">ConnectWithSocket</a> (const char *host, unsigned short remotePort, const char *passwordData, int passwordDataLength, RakNetSmartPtr&lt; RakNetSocket &gt; socket, <a class="el" href="structRakNet_1_1PublicKey.html">PublicKey</a> *publicKey=0, unsigned sendConnectionAttemptCount=12, unsigned timeBetweenSendConnectionAttemptsMS=500, RakNet::TimeMS timeoutTime=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect to the specified host (ip or domain name) and server port, using a shared socket from another instance of <a class="el" href="namespaceRakNet.html" title="Simple class to send changes between directories. In essence, a simple autopatcher...">RakNet</a>.  <a href="#453c82a09aa5c5c8a26f3c9695e589d8"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#4f4acefdc022555862fd386e31f9a22b">Shutdown</a> (unsigned int blockDuration, unsigned char orderingChannel=0, <a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a> disconnectionNotificationPriority=LOW_PRIORITY)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Connect to the specified network ID (Platform specific console function).  <a href="#4f4acefdc022555862fd386e31f9a22b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#ffcba03406b89157976cf0e6a8924d66">IsActive</a> (void) const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#5706fd26cf90bd45d0658d8b9a7d8111">GetConnectionList</a> (<a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> *remoteSystems, unsigned short *numberOfSystems) const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#8587fe2920712adddfa06950ff6b8998">GetNextSendReceipt</a> (void)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#9a406f292a6c44f551e9d8606992558e">IncrementNextSendReceipt</a> (void)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#543ec5be9cf5f73f5c8733d1829789f9">Send</a> (const char *data, const int length, <a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a> priority, <a class="el" href="PacketPriority_8h.html#e41fa01235e99dced384d137fa874a7e">PacketReliability</a> reliability, char orderingChannel, const AddressOrGUID systemIdentifier, bool broadcast, uint32_t forceReceiptNumber=0)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#b8e39273dd7fb89d4b29a01bca32f82c">SendLoopback</a> (const char *data, const int length)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#6d9a5415556a9c138854cc05c707b8e7">Send</a> (const <a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *bitStream, <a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a> priority, <a class="el" href="PacketPriority_8h.html#e41fa01235e99dced384d137fa874a7e">PacketReliability</a> reliability, char orderingChannel, const AddressOrGUID systemIdentifier, bool broadcast, uint32_t forceReceiptNumber=0)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#508111f60de06beb55a65a2b811d557c">SendList</a> (const char **data, const int *lengths, const int numParameters, <a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a> priority, <a class="el" href="PacketPriority_8h.html#e41fa01235e99dced384d137fa874a7e">PacketReliability</a> reliability, char orderingChannel, const AddressOrGUID systemIdentifier, bool broadcast, uint32_t forceReceiptNumber=0)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structRakNet_1_1Packet.html">Packet</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#1c50453d9dee600920aeabd62ad7c119">Receive</a> (void)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#21b929aba61ce69aab32871db33d6ede">DeallocatePacket</a> (<a class="el" href="structRakNet_1_1Packet.html">Packet</a> *packet)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="02072e70ea776c086079e2d69031fd8f"></a><!-- doxytag: member="RakNet::RakPeerInterface::GetMaximumNumberOfPeers" ref="02072e70ea776c086079e2d69031fd8f" args="(void) const =0" -->
virtual unsigned short&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#02072e70ea776c086079e2d69031fd8f">GetMaximumNumberOfPeers</a> (void) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the total number of connections we are allowed. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#fd637c6f44cb84ce5c151c700bb5cafe">CloseConnection</a> (const AddressOrGUID target, bool sendDisconnectionNotification, unsigned char orderingChannel=0, <a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a> disconnectionNotificationPriority=LOW_PRIORITY)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="namespaceRakNet.html#84a0fb005391f71130dd341f77f62138">ConnectionState</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#33744f90a202b8e57d6a825d6af080cc">GetConnectionState</a> (const AddressOrGUID systemIdentifier)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#d70d63c4093c1351f4a0c2949eac312a">CancelConnectionAttempt</a> (const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> target)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#b2015109d6bf787c46880fde513d4276">GetIndexFromSystemAddress</a> (const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> systemAddress) const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#72bcae24dbbf0f0d5bbe0d750790c510">GetSystemAddressFromIndex</a> (int index)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structRakNet_1_1RakNetGUID.html">RakNetGUID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#b1b9f9bde28faa2e4c79d09c7613c4b1">GetGUIDFromIndex</a> (int index)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#a1939c66f7190e3c647a6a685a6eb248">GetSystemList</a> (<a class="el" href="classDataStructures_1_1List.html">DataStructures::List</a>&lt; <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> &gt; &amp;addresses, <a class="el" href="classDataStructures_1_1List.html">DataStructures::List</a>&lt; <a class="el" href="structRakNet_1_1RakNetGUID.html">RakNetGUID</a> &gt; &amp;guids) const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#b44199db81cf4fa834d42efc5eb5ae77">AddToBanList</a> (const char *IP, RakNet::TimeMS milliseconds=0)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#9e18c8dae14157432ddc6f19a8114c1b">RemoveFromBanList</a> (const char *IP)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="79afdfa5e5e87e66dc54b3336a30b68a"></a><!-- doxytag: member="RakNet::RakPeerInterface::ClearBanList" ref="79afdfa5e5e87e66dc54b3336a30b68a" args="(void)=0" -->
virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#79afdfa5e5e87e66dc54b3336a30b68a">ClearBanList</a> (void)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Allows all previously banned IPs to connect. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#e28629f202de81ad4816470cd0f8fd94">IsBanned</a> (const char *IP)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#1c7d098a1d9a4613f051ae3627831af6">SetLimitIPConnectionFrequency</a> (bool b)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#49dbff7ab8f516361e3d05645c2b7901">Ping</a> (const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> target)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#d5667c9d47585be3a65485f9c81f7045">Ping</a> (const char *host, unsigned short remotePort, bool onlyReplyOnAcceptingConnections, unsigned connectionSocketIndex=0)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#15627acab7077970975889d4e83dc59b">GetAveragePing</a> (const AddressOrGUID systemIdentifier)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#0fb0115e5c85094d48239f157d9eccbb">GetLastPing</a> (const AddressOrGUID systemIdentifier) const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#4eb8b0f288db5425906cd72ee5f8fae9">GetLowestPing</a> (const AddressOrGUID systemIdentifier) const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#fdc6e658512d2f01d6bb211758721f21">SetOccasionalPing</a> (bool doPing)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#40b198325a1a4f4a1ff3b1a1741b89eb">SetOfflinePingResponse</a> (const char *data, const unsigned int length)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#e61f8651e8a45acec5bdf04384777a86">GetOfflinePingResponse</a> (char **data, unsigned int *length)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#928a49c193687ccef547f7ea3634bb54">GetInternalID</a> (const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> systemAddress=<a class="el" href="namespaceRakNet.html#80c95b4ed53f42911a6fa92b85e929cf">UNASSIGNED_SYSTEM_ADDRESS</a>, const int index=0) const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#94602ad7356b4a99f862f9793327c325">GetExternalID</a> (const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> target) const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b89d6d78297265c282c22c029a285fa2"></a><!-- doxytag: member="RakNet::RakPeerInterface::GetMyGUID" ref="b89d6d78297265c282c22c029a285fa2" args="(void) const =0" -->
virtual const <a class="el" href="structRakNet_1_1RakNetGUID.html">RakNetGUID</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#b89d6d78297265c282c22c029a285fa2">GetMyGUID</a> (void) const =0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return my own GUID. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a6abdf47bc3e2e016ccd0171a05e125b"></a><!-- doxytag: member="RakNet::RakPeerInterface::GetMyBoundAddress" ref="a6abdf47bc3e2e016ccd0171a05e125b" args="(const int socketIndex=0)=0" -->
virtual <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#a6abdf47bc3e2e016ccd0171a05e125b">GetMyBoundAddress</a> (const int socketIndex=0)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Return the address bound to a socket at the specified index. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const <a class="el" href="structRakNet_1_1RakNetGUID.html">RakNetGUID</a> &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#ac8203dda2ba1271e753bd113b259173">GetGuidFromSystemAddress</a> (const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> input) const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#daaff66118400b6bbcb31c11419cd791">GetSystemAddressFromGuid</a> (const <a class="el" href="structRakNet_1_1RakNetGUID.html">RakNetGUID</a> input) const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#7139f333758a31e5a1f44f06b120f085">GetClientPublicKeyFromSystemAddress</a> (const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> input, char *client_public_key) const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#49d2993d5db12a62ce88dc89700c0880">SetTimeoutTime</a> (RakNet::TimeMS timeMS, const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> target)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual RakNet::TimeMS&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#0fd3a4d282327944ee50b00c79baf420">GetTimeoutTime</a> (const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> target)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#f7359755639152292a3e35b6fb9877bb">GetMTUSize</a> (const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> target) const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="59b3cee62120132170dcf065b84114b2"></a><!-- doxytag: member="RakNet::RakPeerInterface::GetNumberOfAddresses" ref="59b3cee62120132170dcf065b84114b2" args="(void)=0" -->
virtual unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#59b3cee62120132170dcf065b84114b2">GetNumberOfAddresses</a> (void)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of IP addresses this system has internally. Get the actual addresses from <a class="el" href="classRakNet_1_1RakPeerInterface.html#d070246537065910a500803bdf6b9cb2">GetLocalIP()</a>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual const char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#d070246537065910a500803bdf6b9cb2">GetLocalIP</a> (unsigned int index)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#c37fe2c8b35abdc3a441541e539ebd10">IsLocalIP</a> (const char *ip)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#a4a2525f004aaf073e1b25b0ffe0c0d2">AllowConnectionResponseIPMigration</a> (bool allow)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#dccf6f091e1ac19ad92099d50fe649d7">AdvertiseSystem</a> (const char *host, unsigned short remotePort, const char *data, int dataLength, unsigned connectionSocketIndex=0)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#4112544503b05a7b7dd2dd56adfbc648">SetSplitMessageProgressInterval</a> (int interval)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#bd4be92bcad53af859e502127c060247">GetSplitMessageProgressInterval</a> (void) const =0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#87db4b6410fce078080400f8d58328ed">SetUnreliableTimeout</a> (RakNet::TimeMS timeoutMS)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#700a2c9bc1414da194a35076af3b56e0">SendTTL</a> (const char *host, unsigned short remotePort, int ttl, unsigned connectionSocketIndex=0)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#2cfd224842b6f1d5e2881901c9f71531">AttachPlugin</a> (<a class="el" href="classRakNet_1_1PluginInterface2.html">PluginInterface2</a> *plugin)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Attaches a Plugin interface to an instance of the base class (<a class="el" href="classRakNet_1_1RakPeer.html" title="Main interface for network communications.">RakPeer</a> or PacketizedTCP) to run code automatically on message receipt in the Receive call. If the plugin returns false from PluginInterface::UsesReliabilityLayer(), which is the case for all plugins except <a class="el" href="classRakNet_1_1PacketLogger.html" title="Writes incoming and outgoing messages to the screen. This will write all incoming...">PacketLogger</a>, you can call <a class="el" href="classRakNet_1_1RakPeerInterface.html#2cfd224842b6f1d5e2881901c9f71531" title="Attaches a Plugin interface to an instance of the base class (RakPeer or PacketizedTCP)...">AttachPlugin()</a> and <a class="el" href="classRakNet_1_1RakPeerInterface.html#4960f6a8d37d70e7e98f1f6fe54e323d" title="Detaches a Plugin interface from the instance of the base class (RakPeer or PacketizedTCP)...">DetachPlugin()</a> for this plugin while <a class="el" href="classRakNet_1_1RakPeer.html" title="Main interface for network communications.">RakPeer</a> is active.  <a href="#2cfd224842b6f1d5e2881901c9f71531"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#4960f6a8d37d70e7e98f1f6fe54e323d">DetachPlugin</a> (<a class="el" href="classRakNet_1_1PluginInterface2.html">PluginInterface2</a> *messageHandler)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Detaches a Plugin interface from the instance of the base class (<a class="el" href="classRakNet_1_1RakPeer.html" title="Main interface for network communications.">RakPeer</a> or PacketizedTCP) it is attached to.  <a href="#4960f6a8d37d70e7e98f1f6fe54e323d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#29c5527b07a3ddc32083d8ec1e24318b">PushBackPacket</a> (<a class="el" href="structRakNet_1_1Packet.html">Packet</a> *packet, bool pushAtHead)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structRakNet_1_1Packet.html">Packet</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#3e38bdd227138f640a942102813ce779">AllocatePacket</a> (unsigned dataSize)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual RakNetSmartPtr<br class="typebreak">
&lt; RakNetSocket &gt;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#2ac541ad6ae2fcfdf14ab805bdb3caf9">GetSocket</a> (const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> target)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#52329111685593de4d56f5a0d64e93fb">GetSockets</a> (<a class="el" href="classDataStructures_1_1List.html">DataStructures::List</a>&lt; RakNetSmartPtr&lt; RakNetSocket &gt; &gt; &amp;sockets)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#0832004c529aa9a0844b61eaf1374b3c">SetUserUpdateThread</a> (void(*_userUpdateThreadPtr)(<a class="el" href="classRakNet_1_1RakPeerInterface.html">RakPeerInterface</a> *, void *), void *_userUpdateThreadData)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#03910361629f5cbabe0df0612a1f2709">ApplyNetworkSimulator</a> (float packetloss, unsigned short minExtraPing, unsigned short extraPingVariance)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#95daeb743853a4406182e47668c0f33b">SetPerConnectionOutgoingBandwidthLimit</a> (unsigned maxBitsPerSecond)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#917c367bcba491fb243161025b6eab01">IsNetworkSimulatorActive</a> (void)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">virtual <a class="el" href="structRakNet_1_1RakNetStatistics.html">RakNetStatistics</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#87e528130f7f0f21597a338769fe7139">GetStatistics</a> (const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> systemAddress, <a class="el" href="structRakNet_1_1RakNetStatistics.html">RakNetStatistics</a> *rns=0)=0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8f0971a8d45efdf1ce30946195195736"></a><!-- doxytag: member="RakNet::RakPeerInterface::GetReceiveBufferSize" ref="8f0971a8d45efdf1ce30946195195736" args="(void)=0" -->
virtual unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#8f0971a8d45efdf1ce30946195195736">GetReceiveBufferSize</a> (void)=0</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">how many messages are waiting when you call <a class="el" href="classRakNet_1_1RakPeerInterface.html#1c50453d9dee600920aeabd62ad7c119">Receive()</a> <br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8e05f80c6e0de8f1b6e644700b7ce543"></a><!-- doxytag: member="RakNet::RakPeerInterface::Get64BitUniqueRandomNumber" ref="8e05f80c6e0de8f1b6e644700b7ce543" args="(void)" -->
static uint64_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1RakPeerInterface.html#8e05f80c6e0de8f1b6e644700b7ce543">Get64BitUniqueRandomNumber</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get a random number (to generate a GUID). <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The main interface for network communications. 
<p>
The primary interface for <a class="el" href="namespaceRakNet.html" title="Simple class to send changes between directories. In essence, a simple autopatcher...">RakNet</a>, <a class="el" href="classRakNet_1_1RakPeer.html" title="Main interface for network communications.">RakPeer</a> contains all major functions for the library. See the individual functions for what the class can do. <hr><h2>Member Function Documentation</h2>
<a class="anchor" name="b44199db81cf4fa834d42efc5eb5ae77"></a><!-- doxytag: member="RakNet::RakPeerInterface::AddToBanList" ref="b44199db81cf4fa834d42efc5eb5ae77" args="(const char *IP, RakNet::TimeMS milliseconds=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakNet::RakPeerInterface::AddToBanList           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>IP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RakNet::TimeMS&nbsp;</td>
          <td class="paramname"> <em>milliseconds</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bans an IP from connecting. Banned IPs persist between connections but are not saved on shutdown nor loaded on startup. param[in] IP Dotted IP address. Can use * as a wildcard, such as 128.0.0.* will ban all IP addresses starting with 128.0.0 <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>milliseconds</em>&nbsp;</td><td>how many ms for a temporary ban. Use 0 for a permanent ban </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#d403c131efe8bfe6f3c5280e110b9b2d">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="5ba3e8713e5d7b150ed393eced79675d"></a><!-- doxytag: member="RakNet::RakPeerInterface::AddToSecurityExceptionList" ref="5ba3e8713e5d7b150ed393eced79675d" args="(const char *ip)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakNet::RakPeerInterface::AddToSecurityExceptionList           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ip</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If secure connections are on, do not use secure connections for a specific IP address. This is useful if you have a fixed-address internal server behind a LAN. <dl class="note" compact><dt><b>Note:</b></dt><dd>Secure connections are determined by the recipient of an incoming connection. This has no effect if called on the system attempting to connect. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ip</em>&nbsp;</td><td>IP address to add. * wildcards are supported. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#b927e4b0e70fcc0e06d1ba6a70315eb3">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="dccf6f091e1ac19ad92099d50fe649d7"></a><!-- doxytag: member="RakNet::RakPeerInterface::AdvertiseSystem" ref="dccf6f091e1ac19ad92099d50fe649d7" args="(const char *host, unsigned short remotePort, const char *data, int dataLength, unsigned connectionSocketIndex=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool RakNet::RakPeerInterface::AdvertiseSystem           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>remotePort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>dataLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>connectionSocketIndex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sends a one byte message ID_ADVERTISE_SYSTEM to the remote unconnected system. This will tell the remote system our external IP outside the LAN along with some user data. <dl class="pre" compact><dt><b>Precondition:</b></dt><dd>The sender and recipient must already be started via a successful call to Initialize </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>host</em>&nbsp;</td><td>Either a dotted IP address or a domain name </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>remotePort</em>&nbsp;</td><td>Which port to connect to on the remote machine. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>Optional data to append to the packet. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dataLength</em>&nbsp;</td><td>length of data in bytes. Use 0 if no data. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>connectionSocketIndex</em>&nbsp;</td><td>Index into the array of socket descriptors passed to socketDescriptors in <a class="el" href="classRakNet_1_1RakPeer.html#de24b8bf50eb756f54a208c2841f5e0d" title="Starts the network threads and opens the listen port.">RakPeer::Startup()</a> to send on. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>false if <a class="el" href="classRakNet_1_1RakPeerInterface.html#ffcba03406b89157976cf0e6a8924d66">IsActive()</a>==false or the host is unresolvable. True otherwise </dd></dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#ecb0396cdb296a5df8b8266c8cce138d">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="3e38bdd227138f640a942102813ce779"></a><!-- doxytag: member="RakNet::RakPeerInterface::AllocatePacket" ref="3e38bdd227138f640a942102813ce779" args="(unsigned dataSize)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structRakNet_1_1Packet.html">Packet</a>* RakNet::RakPeerInterface::AllocatePacket           </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>dataSize</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>a packet for you to write to if you want to create a <a class="el" href="structRakNet_1_1Packet.html" title="This represents a user message from another system.">Packet</a> for some reason. You can add it to the receive buffer with PushBackPacket </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dataSize</em>&nbsp;</td><td>How many bytes to allocate for the buffer </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A packet you can write to </dd></dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#5be8b42a06fdd32f29f032ba5fc5e7b0">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="a4a2525f004aaf073e1b25b0ffe0c0d2"></a><!-- doxytag: member="RakNet::RakPeerInterface::AllowConnectionResponseIPMigration" ref="a4a2525f004aaf073e1b25b0ffe0c0d2" args="(bool allow)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakNet::RakPeerInterface::AllowConnectionResponseIPMigration           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>allow</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allow or disallow connection responses from any IP. Normally this should be false, but may be necessary when connecting to servers with multiple IP addresses. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>allow</em>&nbsp;</td><td>- True to allow this behavior, false to not allow. Defaults to false. Value persists between connections </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#3b24a4946b34071621b0b288b869f21f">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="03910361629f5cbabe0df0612a1f2709"></a><!-- doxytag: member="RakNet::RakPeerInterface::ApplyNetworkSimulator" ref="03910361629f5cbabe0df0612a1f2709" args="(float packetloss, unsigned short minExtraPing, unsigned short extraPingVariance)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakNet::RakPeerInterface::ApplyNetworkSimulator           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>packetloss</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>minExtraPing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>extraPingVariance</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds simulated ping and packet loss to the outgoing data flow. To simulate bi-directional ping and packet loss, you should call this on both the sender and the recipient, with half the total ping and packetloss value on each. You can exclude network simulator code with the _RELEASE define to decrease code size <dl compact><dt><b><a class="el" href="deprecated.html#_deprecated000002">Deprecated:</a></b></dt><dd>Use <a href="http://www.jenkinssoftware.com/forum/index.php?topic=1671.0">http://www.jenkinssoftware.com/forum/index.php?topic=1671.0</a> instead. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Doesn't work past version 3.6201 </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>packetloss</em>&nbsp;</td><td>Chance to lose a packet. Ranges from 0 to 1. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>minExtraPing</em>&nbsp;</td><td>The minimum time to delay sends. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>extraPingVariance</em>&nbsp;</td><td>The additional random time to delay sends. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#38a4348d90eb454b4d470d45fb19b99e">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="2cfd224842b6f1d5e2881901c9f71531"></a><!-- doxytag: member="RakNet::RakPeerInterface::AttachPlugin" ref="2cfd224842b6f1d5e2881901c9f71531" args="(PluginInterface2 *plugin)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakNet::RakPeerInterface::AttachPlugin           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRakNet_1_1PluginInterface2.html">PluginInterface2</a> *&nbsp;</td>
          <td class="paramname"> <em>plugin</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Attaches a Plugin interface to an instance of the base class (<a class="el" href="classRakNet_1_1RakPeer.html" title="Main interface for network communications.">RakPeer</a> or PacketizedTCP) to run code automatically on message receipt in the Receive call. If the plugin returns false from PluginInterface::UsesReliabilityLayer(), which is the case for all plugins except <a class="el" href="classRakNet_1_1PacketLogger.html" title="Writes incoming and outgoing messages to the screen. This will write all incoming...">PacketLogger</a>, you can call <a class="el" href="classRakNet_1_1RakPeerInterface.html#2cfd224842b6f1d5e2881901c9f71531" title="Attaches a Plugin interface to an instance of the base class (RakPeer or PacketizedTCP)...">AttachPlugin()</a> and <a class="el" href="classRakNet_1_1RakPeerInterface.html#4960f6a8d37d70e7e98f1f6fe54e323d" title="Detaches a Plugin interface from the instance of the base class (RakPeer or PacketizedTCP)...">DetachPlugin()</a> for this plugin while <a class="el" href="classRakNet_1_1RakPeer.html" title="Main interface for network communications.">RakPeer</a> is active. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>messageHandler</em>&nbsp;</td><td>Pointer to the plugin to attach. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#4ceacd63ae51089a2e36287c54f07ffe">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="d70d63c4093c1351f4a0c2949eac312a"></a><!-- doxytag: member="RakNet::RakPeerInterface::CancelConnectionAttempt" ref="d70d63c4093c1351f4a0c2949eac312a" args="(const SystemAddress target)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakNet::RakPeerInterface::CancelConnectionAttempt           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>target</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Cancel a pending connection attempt If we are already connected, the connection stays open <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>target</em>&nbsp;</td><td>Which system to cancel </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#5f934680b37ffbfdc0047ac406fc2512">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="fd637c6f44cb84ce5c151c700bb5cafe"></a><!-- doxytag: member="RakNet::RakPeerInterface::CloseConnection" ref="fd637c6f44cb84ce5c151c700bb5cafe" args="(const AddressOrGUID target, bool sendDisconnectionNotification, unsigned char orderingChannel=0, PacketPriority disconnectionNotificationPriority=LOW_PRIORITY)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakNet::RakPeerInterface::CloseConnection           </td>
          <td>(</td>
          <td class="paramtype">const AddressOrGUID&nbsp;</td>
          <td class="paramname"> <em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>sendDisconnectionNotification</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>orderingChannel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a>&nbsp;</td>
          <td class="paramname"> <em>disconnectionNotificationPriority</em> = <code>LOW_PRIORITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Close the connection to another host (if we initiated the connection it will disconnect, if they did it will kick them out). <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>target</em>&nbsp;</td><td>Which system to close the connection to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sendDisconnectionNotification</em>&nbsp;</td><td>True to send ID_DISCONNECTION_NOTIFICATION to the recipient. False to close it silently. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>channel</em>&nbsp;</td><td>Which ordering channel to send the disconnection notification on, if any </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>disconnectionNotificationPriority</em>&nbsp;</td><td>Priority to send ID_DISCONNECTION_NOTIFICATION on. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#95e3806fce8552e322236abcf105cbf9">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="451dd5d225277fe5806d3d700551fb76"></a><!-- doxytag: member="RakNet::RakPeerInterface::Connect" ref="451dd5d225277fe5806d3d700551fb76" args="(const char *host, unsigned short remotePort, const char *passwordData, int passwordDataLength, PublicKey *publicKey=0, unsigned connectionSocketIndex=0, unsigned sendConnectionAttemptCount=12, unsigned timeBetweenSendConnectionAttemptsMS=500, RakNet::TimeMS timeoutTime=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ConnectionAttemptResult RakNet::RakPeerInterface::Connect           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>remotePort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>passwordData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>passwordDataLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRakNet_1_1PublicKey.html">PublicKey</a> *&nbsp;</td>
          <td class="paramname"> <em>publicKey</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>connectionSocketIndex</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>sendConnectionAttemptCount</em> = <code>12</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>timeBetweenSendConnectionAttemptsMS</em> = <code>500</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RakNet::TimeMS&nbsp;</td>
          <td class="paramname"> <em>timeoutTime</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connect to the specified host (ip or domain name) and server port. Calling Connect and not calling SetMaximumIncomingConnections acts as a dedicated client. Calling both acts as a true peer. This is a non-blocking connection. You know the connection is successful when <a class="el" href="classRakNet_1_1RakPeerInterface.html#33744f90a202b8e57d6a825d6af080cc">GetConnectionState()</a> returns IS_CONNECTED or <a class="el" href="classRakNet_1_1RakPeerInterface.html#1c50453d9dee600920aeabd62ad7c119">Receive()</a> gets a message with the type identifier ID_CONNECTION_REQUEST_ACCEPTED. If the connection is not successful, such as a rejected connection or no response then neither of these things will happen. 
<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>Requires that you first call Initialize </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>host</em>&nbsp;</td><td>Either a dotted IP address or a domain name </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>remotePort</em>&nbsp;</td><td>Which port to connect to on the remote machine. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>passwordData</em>&nbsp;</td><td>A data block that must match the data block on the server passed to SetIncomingPassword. This can be a string or can be a stream of data. Use 0 for no password. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>passwordDataLength</em>&nbsp;</td><td>The length in bytes of passwordData </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>publicKey</em>&nbsp;</td><td>The public key the server is using. If 0, the server is not using security. If non-zero, the publicKeyMode member determines how to connect </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>connectionSocketIndex</em>&nbsp;</td><td>Index into the array of socket descriptors passed to socketDescriptors in <a class="el" href="classRakNet_1_1RakPeer.html#de24b8bf50eb756f54a208c2841f5e0d" title="Starts the network threads and opens the listen port.">RakPeer::Startup()</a> to send on. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sendConnectionAttemptCount</em>&nbsp;</td><td>How many datagrams to send to the other system to try to connect. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeBetweenSendConnectionAttemptsMS</em>&nbsp;</td><td>Time to elapse before a datagram is sent to the other system to try to connect. After sendConnectionAttemptCount number of attempts, ID_CONNECTION_ATTEMPT_FAILED is returned. Under low bandwidth conditions with multiple simultaneous outgoing connections, this value should be raised to 1000 or higher, or else the MTU detection can overrun the available bandwidth. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeoutTime</em>&nbsp;</td><td>How long to keep the connection alive before dropping it on unable to send a reliable message. 0 to use the default from SetTimeoutTime(UNASSIGNED_SYSTEM_ADDRESS); </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>CONNECTION_ATTEMPT_STARTED on successful initiation. Otherwise, an appropriate enumeration indicating failure. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>CONNECTION_ATTEMPT_STARTED does not mean you are already connected! <p>
It is possible to immediately get back ID_CONNECTION_ATTEMPT_FAILED if you exceed the maxConnections parameter passed to <a class="el" href="classRakNet_1_1RakPeerInterface.html#3c8c414844a87707c28cdf35f41a5f00" title="Starts the network threads, opens the listen port.">Startup()</a>. This could happen if you call <a class="el" href="classRakNet_1_1RakPeerInterface.html#fd637c6f44cb84ce5c151c700bb5cafe">CloseConnection()</a> with sendDisconnectionNotificaiton true, then immediately call <a class="el" href="classRakNet_1_1RakPeerInterface.html#451dd5d225277fe5806d3d700551fb76" title="Connect to the specified host (ip or domain name) and server port. Calling Connect...">Connect()</a> before the connection has closed. </dd></dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#19979ff2acc15abe22785fc55c1c656c">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="453c82a09aa5c5c8a26f3c9695e589d8"></a><!-- doxytag: member="RakNet::RakPeerInterface::ConnectWithSocket" ref="453c82a09aa5c5c8a26f3c9695e589d8" args="(const char *host, unsigned short remotePort, const char *passwordData, int passwordDataLength, RakNetSmartPtr&lt; RakNetSocket &gt; socket, PublicKey *publicKey=0, unsigned sendConnectionAttemptCount=12, unsigned timeBetweenSendConnectionAttemptsMS=500, RakNet::TimeMS timeoutTime=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual ConnectionAttemptResult RakNet::RakPeerInterface::ConnectWithSocket           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>remotePort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>passwordData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>passwordDataLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RakNetSmartPtr&lt; RakNetSocket &gt;&nbsp;</td>
          <td class="paramname"> <em>socket</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRakNet_1_1PublicKey.html">PublicKey</a> *&nbsp;</td>
          <td class="paramname"> <em>publicKey</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>sendConnectionAttemptCount</em> = <code>12</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>timeBetweenSendConnectionAttemptsMS</em> = <code>500</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RakNet::TimeMS&nbsp;</td>
          <td class="paramname"> <em>timeoutTime</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connect to the specified host (ip or domain name) and server port, using a shared socket from another instance of <a class="el" href="namespaceRakNet.html" title="Simple class to send changes between directories. In essence, a simple autopatcher...">RakNet</a>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>host</em>&nbsp;</td><td>Either a dotted IP address or a domain name </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>remotePort</em>&nbsp;</td><td>Which port to connect to on the remote machine. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>passwordData</em>&nbsp;</td><td>A data block that must match the data block on the server passed to SetIncomingPassword. This can be a string or can be a stream of data. Use 0 for no password. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>passwordDataLength</em>&nbsp;</td><td>The length in bytes of passwordData </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>socket</em>&nbsp;</td><td>A bound socket returned by another instance of <a class="el" href="classRakNet_1_1RakPeerInterface.html" title="The main interface for network communications.">RakPeerInterface</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sendConnectionAttemptCount</em>&nbsp;</td><td>How many datagrams to send to the other system to try to connect. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeBetweenSendConnectionAttemptsMS</em>&nbsp;</td><td>Time to elapse before a datagram is sent to the other system to try to connect. After sendConnectionAttemptCount number of attempts, ID_CONNECTION_ATTEMPT_FAILED is returned. Under low bandwidth conditions with multiple simultaneous outgoing connections, this value should be raised to 1000 or higher, or else the MTU detection can overrun the available bandwidth. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeoutTime</em>&nbsp;</td><td>How long to keep the connection alive before dropping it on unable to send a reliable message. 0 to use the default from SetTimeoutTime(UNASSIGNED_SYSTEM_ADDRESS); </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>CONNECTION_ATTEMPT_STARTED on successful initiation. Otherwise, an appropriate enumeration indicating failure. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>CONNECTION_ATTEMPT_STARTED does not mean you are already connected! </dd></dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#9f5490f5b9fd62fb8261b9f7c33fd960">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="21b929aba61ce69aab32871db33d6ede"></a><!-- doxytag: member="RakNet::RakPeerInterface::DeallocatePacket" ref="21b929aba61ce69aab32871db33d6ede" args="(Packet *packet)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakNet::RakPeerInterface::DeallocatePacket           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRakNet_1_1Packet.html">Packet</a> *&nbsp;</td>
          <td class="paramname"> <em>packet</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Call this to deallocate a message returned by <a class="el" href="classRakNet_1_1RakPeerInterface.html#1c50453d9dee600920aeabd62ad7c119">Receive()</a> when you are done handling it. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>packet</em>&nbsp;</td><td>The message to deallocate. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#e3e053f8f77d9b2e7b7fcd03f8f9120e">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="4960f6a8d37d70e7e98f1f6fe54e323d"></a><!-- doxytag: member="RakNet::RakPeerInterface::DetachPlugin" ref="4960f6a8d37d70e7e98f1f6fe54e323d" args="(PluginInterface2 *messageHandler)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakNet::RakPeerInterface::DetachPlugin           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRakNet_1_1PluginInterface2.html">PluginInterface2</a> *&nbsp;</td>
          <td class="paramname"> <em>messageHandler</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Detaches a Plugin interface from the instance of the base class (<a class="el" href="classRakNet_1_1RakPeer.html" title="Main interface for network communications.">RakPeer</a> or PacketizedTCP) it is attached to. 
<p>
This method disables the plugin code from running automatically on base class's updates or message receipt. If the plugin returns false from PluginInterface::UsesReliabilityLayer(), which is the case for all plugins except <a class="el" href="classRakNet_1_1PacketLogger.html" title="Writes incoming and outgoing messages to the screen. This will write all incoming...">PacketLogger</a>, you can call <a class="el" href="classRakNet_1_1RakPeerInterface.html#2cfd224842b6f1d5e2881901c9f71531" title="Attaches a Plugin interface to an instance of the base class (RakPeer or PacketizedTCP)...">AttachPlugin()</a> and <a class="el" href="classRakNet_1_1RakPeerInterface.html#4960f6a8d37d70e7e98f1f6fe54e323d" title="Detaches a Plugin interface from the instance of the base class (RakPeer or PacketizedTCP)...">DetachPlugin()</a> for this plugin while <a class="el" href="classRakNet_1_1RakPeer.html" title="Main interface for network communications.">RakPeer</a> is active. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>messageHandler</em>&nbsp;</td><td>Pointer to a plugin to detach. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#9f29151642a0ad0abdddc6d9a8f25239">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="ab566dbe8f666dfed108aaaabc7a0ca6"></a><!-- doxytag: member="RakNet::RakPeerInterface::DisableSecurity" ref="ab566dbe8f666dfed108aaaabc7a0ca6" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakNet::RakPeerInterface::DisableSecurity           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Disables security for incoming connections. <dl class="note" compact><dt><b>Note:</b></dt><dd>Must be called while offline </dd></dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#489dd712e953836042df5711c8eb7e76">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="15627acab7077970975889d4e83dc59b"></a><!-- doxytag: member="RakNet::RakPeerInterface::GetAveragePing" ref="15627acab7077970975889d4e83dc59b" args="(const AddressOrGUID systemIdentifier)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int RakNet::RakPeerInterface::GetAveragePing           </td>
          <td>(</td>
          <td class="paramtype">const AddressOrGUID&nbsp;</td>
          <td class="paramname"> <em>systemIdentifier</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the average of all ping times read for the specific system or -1 if none read yet <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>Which system we are referring to </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The ping time for this system, or -1 </dd></dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#2b735d6075d64dcdf5c554989f4a5f98">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="7139f333758a31e5a1f44f06b120f085"></a><!-- doxytag: member="RakNet::RakPeerInterface::GetClientPublicKeyFromSystemAddress" ref="7139f333758a31e5a1f44f06b120f085" args="(const SystemAddress input, char *client_public_key) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool RakNet::RakPeerInterface::GetClientPublicKeyFromSystemAddress           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>client_public_key</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given the <a class="el" href="structRakNet_1_1SystemAddress.html" title="Network address for a system.">SystemAddress</a> of a connected system, get the public key they provided as an identity Returns false if system address was not found or client public key is not known <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>input</em>&nbsp;</td><td>The <a class="el" href="structRakNet_1_1RakNetGUID.html">RakNetGUID</a> of the system </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>client_public_key</em>&nbsp;</td><td>The connected client's public key is copied to this address. Buffer must be cat::EasyHandshake::PUBLIC_KEY_BYTES bytes in length. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#bc607f77d9724097030d2da6868074b3">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="5706fd26cf90bd45d0658d8b9a7d8111"></a><!-- doxytag: member="RakNet::RakPeerInterface::GetConnectionList" ref="5706fd26cf90bd45d0658d8b9a7d8111" args="(SystemAddress *remoteSystems, unsigned short *numberOfSystems) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool RakNet::RakPeerInterface::GetConnectionList           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> *&nbsp;</td>
          <td class="paramname"> <em>remoteSystems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short *&nbsp;</td>
          <td class="paramname"> <em>numberOfSystems</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Fills the array remoteSystems with the <a class="el" href="structRakNet_1_1SystemAddress.html" title="Network address for a system.">SystemAddress</a> of all the systems we are connected to <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>remoteSystems</em>&nbsp;</td><td>An array of <a class="el" href="structRakNet_1_1SystemAddress.html" title="Network address for a system.">SystemAddress</a> structures to be filled with the SystemAddresss of the systems we are connected to. Pass 0 to remoteSystems to only get the number of systems we are connected to </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>numberOfSystems</em>&nbsp;</td><td>As input, the size of remoteSystems array. As output, the number of elements put into the array </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#0af5b69face182410f2abb11da902dd4">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="33744f90a202b8e57d6a825d6af080cc"></a><!-- doxytag: member="RakNet::RakPeerInterface::GetConnectionState" ref="33744f90a202b8e57d6a825d6af080cc" args="(const AddressOrGUID systemIdentifier)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceRakNet.html#84a0fb005391f71130dd341f77f62138">ConnectionState</a> RakNet::RakPeerInterface::GetConnectionState           </td>
          <td>(</td>
          <td class="paramtype">const AddressOrGUID&nbsp;</td>
          <td class="paramname"> <em>systemIdentifier</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns if a system is connected, disconnected, connecting in progress, or various other states <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemIdentifier</em>&nbsp;</td><td>The system we are referring to </td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This locks a mutex, do not call too frequently during connection attempts or the attempt will take longer and possibly even timeout </dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>What state the remote system is in </dd></dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#514c8d6f1dc75b5e9bb3cb5b9dcb632b">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="94602ad7356b4a99f862f9793327c325"></a><!-- doxytag: member="RakNet::RakPeerInterface::GetExternalID" ref="94602ad7356b4a99f862f9793327c325" args="(const SystemAddress target) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> RakNet::RakPeerInterface::GetExternalID           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>target</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the unique address identifier that represents you on the the network and is based on your externalIP / port (the IP / port the specified player uses to communicate with you) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>target</em>&nbsp;</td><td>Which remote system you are referring to for your external ID. Usually the same for all systems, unless you have two or more network cards. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#96f0e923c413fe2319d17862605d6622">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="b1b9f9bde28faa2e4c79d09c7613c4b1"></a><!-- doxytag: member="RakNet::RakPeerInterface::GetGUIDFromIndex" ref="b1b9f9bde28faa2e4c79d09c7613c4b1" args="(int index)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structRakNet_1_1RakNetGUID.html">RakNetGUID</a> RakNet::RakPeerInterface::GetGUIDFromIndex           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as GetSystemAddressFromIndex but returns <a class="el" href="structRakNet_1_1RakNetGUID.html">RakNetGUID</a> <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>Index should range between 0 and the maximum number of players allowed - 1. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="structRakNet_1_1RakNetGUID.html">RakNetGUID</a> </dd></dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#994301b7a75108bafaf7479ab1a09db1">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="ac8203dda2ba1271e753bd113b259173"></a><!-- doxytag: member="RakNet::RakPeerInterface::GetGuidFromSystemAddress" ref="ac8203dda2ba1271e753bd113b259173" args="(const SystemAddress input) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="structRakNet_1_1RakNetGUID.html">RakNetGUID</a>&amp; RakNet::RakPeerInterface::GetGuidFromSystemAddress           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>input</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given a connected system, give us the unique GUID representing that instance of <a class="el" href="classRakNet_1_1RakPeer.html" title="Main interface for network communications.">RakPeer</a>. This will be the same on all systems connected to that instance of <a class="el" href="classRakNet_1_1RakPeer.html" title="Main interface for network communications.">RakPeer</a>, even if the external system addresses are different Currently O(log(n)), but this may be improved in the future. If you use this frequently, you may want to cache the value as it won't change. Returns UNASSIGNED_RAKNET_GUID if system address can't be found. If <em>input</em> is UNASSIGNED_SYSTEM_ADDRESS, will return your own GUID <dl class="pre" compact><dt><b>Precondition:</b></dt><dd>Call <a class="el" href="classRakNet_1_1RakPeerInterface.html#3c8c414844a87707c28cdf35f41a5f00" title="Starts the network threads, opens the listen port.">Startup()</a> first, or the function will return UNASSIGNED_RAKNET_GUID </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>input</em>&nbsp;</td><td>The system address of the system we are connected to </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#41fcd1175cb8fee67b12835944ed51da">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="8b5026f40cf8e6f307e2d3ac82970a30"></a><!-- doxytag: member="RakNet::RakPeerInterface::GetIncomingPassword" ref="8b5026f40cf8e6f307e2d3ac82970a30" args="(char *passwordData, int *passwordDataLength)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakNet::RakPeerInterface::GetIncomingPassword           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>passwordData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>passwordDataLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the password passed to SetIncomingPassword <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>passwordData</em>&nbsp;</td><td>Should point to a block large enough to hold the password data you passed to <a class="el" href="classRakNet_1_1RakPeerInterface.html#d18a28a99420006d020125eea1ded4ed">SetIncomingPassword()</a> </td></tr>
    <tr><td valign="top"><tt>[in,out]</tt>&nbsp;</td><td valign="top"><em>passwordDataLength</em>&nbsp;</td><td>Maximum size of the array passwordData. Modified to hold the number of bytes actually written </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#395e269dce0de14f22bfb870923f22b3">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="b2015109d6bf787c46880fde513d4276"></a><!-- doxytag: member="RakNet::RakPeerInterface::GetIndexFromSystemAddress" ref="b2015109d6bf787c46880fde513d4276" args="(const SystemAddress systemAddress) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int RakNet::RakPeerInterface::GetIndexFromSystemAddress           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>systemAddress</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given a systemAddress, returns an index from 0 to the maximum number of players allowed - 1. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>The <a class="el" href="structRakNet_1_1SystemAddress.html" title="Network address for a system.">SystemAddress</a> we are referring to </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The index of this <a class="el" href="structRakNet_1_1SystemAddress.html" title="Network address for a system.">SystemAddress</a> or -1 on system not found. </dd></dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#d77373ffe92c37f01b39bc16c62ac9ba">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="928a49c193687ccef547f7ea3634bb54"></a><!-- doxytag: member="RakNet::RakPeerInterface::GetInternalID" ref="928a49c193687ccef547f7ea3634bb54" args="(const SystemAddress systemAddress=UNASSIGNED_SYSTEM_ADDRESS, const int index=0) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> RakNet::RakPeerInterface::GetInternalID           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>systemAddress</em> = <code><a class="el" href="namespaceRakNet.html#80c95b4ed53f42911a6fa92b85e929cf">UNASSIGNED_SYSTEM_ADDRESS</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>index</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Return the unique address identifier that represents you or another system on the the network and is based on your local IP / port. <dl class="note" compact><dt><b>Note:</b></dt><dd>Not supported by the XBOX </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>Use UNASSIGNED_SYSTEM_ADDRESS to get your behind-LAN address. Use a connected system to get their behind-LAN address </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>When you have multiple internal IDs, which index to return? Currently limited to MAXIMUM_NUMBER_OF_INTERNAL_IDS (so the maximum value of this variable is MAXIMUM_NUMBER_OF_INTERNAL_IDS-1) </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>the identifier of your system internally, which may not be how other systems see if you if you are behind a NAT or proxy </dd></dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#cf82a248aa543c9ec04567c14004fea5">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="0fb0115e5c85094d48239f157d9eccbb"></a><!-- doxytag: member="RakNet::RakPeerInterface::GetLastPing" ref="0fb0115e5c85094d48239f157d9eccbb" args="(const AddressOrGUID systemIdentifier) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int RakNet::RakPeerInterface::GetLastPing           </td>
          <td>(</td>
          <td class="paramtype">const AddressOrGUID&nbsp;</td>
          <td class="paramname"> <em>systemIdentifier</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the last ping time read for the specific system or -1 if none read yet <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>Which system we are referring to </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The last ping time for this system, or -1 </dd></dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#7a21e884778d65fb4493b29e5c1826c5">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="d070246537065910a500803bdf6b9cb2"></a><!-- doxytag: member="RakNet::RakPeerInterface::GetLocalIP" ref="d070246537065910a500803bdf6b9cb2" args="(unsigned int index)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* RakNet::RakPeerInterface::GetLocalIP           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns an IP address at index 0 to GetNumberOfAddresses-1 <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>index into the list of IP addresses </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The local IP address at this index </dd></dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#a78c5de86816a54cae137bffb7e49bc5">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="4eb8b0f288db5425906cd72ee5f8fae9"></a><!-- doxytag: member="RakNet::RakPeerInterface::GetLowestPing" ref="4eb8b0f288db5425906cd72ee5f8fae9" args="(const AddressOrGUID systemIdentifier) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int RakNet::RakPeerInterface::GetLowestPing           </td>
          <td>(</td>
          <td class="paramtype">const AddressOrGUID&nbsp;</td>
          <td class="paramname"> <em>systemIdentifier</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the lowest ping time read or -1 if none read yet <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress</em>&nbsp;</td><td>Which system we are referring to </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The lowest ping time for this system, or -1 </dd></dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#fdb8673a54a5f3926ac93e13a4a20367">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="39ae7c5a36a3049f34ac7fc0ad9d9478"></a><!-- doxytag: member="RakNet::RakPeerInterface::GetMaximumIncomingConnections" ref="39ae7c5a36a3049f34ac7fc0ad9d9478" args="(void) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned short RakNet::RakPeerInterface::GetMaximumIncomingConnections           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the value passed to <a class="el" href="classRakNet_1_1RakPeerInterface.html#1f279ee0d3578de483126f6cfef282f4">SetMaximumIncomingConnections()</a> <dl class="return" compact><dt><b>Returns:</b></dt><dd>the maximum number of incoming connections, which is always &lt;= maxConnections </dd></dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#daf780c2e48d76198c758604e40a7880">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="f7359755639152292a3e35b6fb9877bb"></a><!-- doxytag: member="RakNet::RakPeerInterface::GetMTUSize" ref="f7359755639152292a3e35b6fb9877bb" args="(const SystemAddress target) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int RakNet::RakPeerInterface::GetMTUSize           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>target</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the current MTU size <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>target</em>&nbsp;</td><td>Which system to get this for. UNASSIGNED_SYSTEM_ADDRESS to get the default </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The current MTU size </dd></dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#f5948dcad656f51305ed20c8b38e529b">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="8587fe2920712adddfa06950ff6b8998"></a><!-- doxytag: member="RakNet::RakPeerInterface::GetNextSendReceipt" ref="8587fe2920712adddfa06950ff6b8998" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t RakNet::RakPeerInterface::GetNextSendReceipt           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the next uint32_t that <a class="el" href="classRakNet_1_1RakPeerInterface.html#543ec5be9cf5f73f5c8733d1829789f9">Send()</a> will return <dl class="note" compact><dt><b>Note:</b></dt><dd>If using <a class="el" href="classRakNet_1_1RakPeer.html" title="Main interface for network communications.">RakPeer</a> from multiple threads, this may not be accurate for your thread. Use <a class="el" href="classRakNet_1_1RakPeerInterface.html#9a406f292a6c44f551e9d8606992558e">IncrementNextSendReceipt()</a> in that case. </dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The next uint32_t that <a class="el" href="classRakNet_1_1RakPeerInterface.html#543ec5be9cf5f73f5c8733d1829789f9">Send()</a> or SendList will return </dd></dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#1d6e283f476bdd4ed8b9b4c56693ecd1">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="e61f8651e8a45acec5bdf04384777a86"></a><!-- doxytag: member="RakNet::RakPeerInterface::GetOfflinePingResponse" ref="e61f8651e8a45acec5bdf04384777a86" args="(char **data, unsigned int *length)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakNet::RakPeerInterface::GetOfflinePingResponse           </td>
          <td>(</td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns pointers to a copy of the data passed to SetOfflinePingResponse <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>A pointer to a copy of the data passed to <em><a class="el" href="classRakNet_1_1RakPeerInterface.html#40b198325a1a4f4a1ff3b1a1741b89eb">SetOfflinePingResponse()</a></em> </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>A pointer filled in with the length parameter passed to <a class="el" href="classRakNet_1_1RakPeerInterface.html#40b198325a1a4f4a1ff3b1a1741b89eb">SetOfflinePingResponse()</a> </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="classRakNet_1_1RakPeerInterface.html#40b198325a1a4f4a1ff3b1a1741b89eb">SetOfflinePingResponse</a> </dd></dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#ec33659d51a00eed12bd1dc8a24071b0">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="2ac541ad6ae2fcfdf14ab805bdb3caf9"></a><!-- doxytag: member="RakNet::RakPeerInterface::GetSocket" ref="2ac541ad6ae2fcfdf14ab805bdb3caf9" args="(const SystemAddress target)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual RakNetSmartPtr&lt;RakNetSocket&gt; RakNet::RakPeerInterface::GetSocket           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>target</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the socket used with a particular active connection The smart pointer reference counts the RakNetSocket object, so the socket will remain active as long as the smart pointer does, even if <a class="el" href="namespaceRakNet.html" title="Simple class to send changes between directories. In essence, a simple autopatcher...">RakNet</a> were to shutdown or close the connection. <dl class="note" compact><dt><b>Note:</b></dt><dd>This sends a query to the thread and blocks on the return value for up to one second. In practice it should only take a millisecond or so. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>target</em>&nbsp;</td><td>Which system </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A smart pointer object containing the socket information about the socket. Be sure to check IsNull() which is returned if the update thread is unresponsive, shutting down, or if this system is not connected </dd></dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#01149dc59b7a3fa0c8c5702ccce9e128">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="52329111685593de4d56f5a0d64e93fb"></a><!-- doxytag: member="RakNet::RakPeerInterface::GetSockets" ref="52329111685593de4d56f5a0d64e93fb" args="(DataStructures::List&lt; RakNetSmartPtr&lt; RakNetSocket &gt; &gt; &amp;sockets)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakNet::RakPeerInterface::GetSockets           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDataStructures_1_1List.html">DataStructures::List</a>&lt; RakNetSmartPtr&lt; RakNetSocket &gt; &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>sockets</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get all sockets in use <dl class="note" compact><dt><b>Note:</b></dt><dd>This sends a query to the thread and blocks on the return value for up to one second. In practice it should only take a millisecond or so. </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>sockets</em>&nbsp;</td><td>List of RakNetSocket structures in use. Sockets will not be closed until <em>sockets</em> goes out of scope </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#ec22a93469511414b6df792a8d6d872c">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="bd4be92bcad53af859e502127c060247"></a><!-- doxytag: member="RakNet::RakPeerInterface::GetSplitMessageProgressInterval" ref="bd4be92bcad53af859e502127c060247" args="(void) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual int RakNet::RakPeerInterface::GetSplitMessageProgressInterval           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns what was passed to <a class="el" href="classRakNet_1_1RakPeerInterface.html#4112544503b05a7b7dd2dd56adfbc648">SetSplitMessageProgressInterval()</a> <dl class="return" compact><dt><b>Returns:</b></dt><dd>What was passed to <a class="el" href="classRakNet_1_1RakPeerInterface.html#4112544503b05a7b7dd2dd56adfbc648">SetSplitMessageProgressInterval()</a>. Default to 0. </dd></dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#f9f01256eab673794028fe48980ef6fa">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="87e528130f7f0f21597a338769fe7139"></a><!-- doxytag: member="RakNet::RakPeerInterface::GetStatistics" ref="87e528130f7f0f21597a338769fe7139" args="(const SystemAddress systemAddress, RakNetStatistics *rns=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structRakNet_1_1RakNetStatistics.html">RakNetStatistics</a>* RakNet::RakPeerInterface::GetStatistics           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>systemAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRakNet_1_1RakNetStatistics.html">RakNetStatistics</a> *&nbsp;</td>
          <td class="paramname"> <em>rns</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a structure containing a large set of network statistics for the specified system. You can map this data to a string using the C style <a class="el" href="namespaceRakNet.html#49d0ff9db0d324a890e9c08add72a131">StatisticsToString()</a> function <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemAddress,:</em>&nbsp;</td><td>Which connected system to get statistics for </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rns</em>&nbsp;</td><td>If you supply this structure, it will be written to it. Otherwise it will use a static struct, which is not threadsafe </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on can't find the specified system. A pointer to a set of data otherwise. </dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="RakNetStatistics_8h.html" title="A structure that holds all statistical data returned by RakNet.">RakNetStatistics.h</a> </dd></dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#0d31a8a91862a6c796730dc3a35f98ee">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="daaff66118400b6bbcb31c11419cd791"></a><!-- doxytag: member="RakNet::RakPeerInterface::GetSystemAddressFromGuid" ref="daaff66118400b6bbcb31c11419cd791" args="(const RakNetGUID input) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> RakNet::RakPeerInterface::GetSystemAddressFromGuid           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRakNet_1_1RakNetGUID.html">RakNetGUID</a>&nbsp;</td>
          <td class="paramname"> <em>input</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given the GUID of a connected system, give us the system address of that system. The GUID will be the same on all systems connected to that instance of <a class="el" href="classRakNet_1_1RakPeer.html" title="Main interface for network communications.">RakPeer</a>, even if the external system addresses are different Currently O(log(n)), but this may be improved in the future. If you use this frequently, you may want to cache the value as it won't change. If <em>input</em> is UNASSIGNED_RAKNET_GUID, will return UNASSIGNED_SYSTEM_ADDRESS <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>input</em>&nbsp;</td><td>The <a class="el" href="structRakNet_1_1RakNetGUID.html">RakNetGUID</a> of the system we are checking to see if we are connected to </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#c591b0ac4b88b9cdf182fc4769d9de98">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="72bcae24dbbf0f0d5bbe0d750790c510"></a><!-- doxytag: member="RakNet::RakPeerInterface::GetSystemAddressFromIndex" ref="72bcae24dbbf0f0d5bbe0d750790c510" args="(int index)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> RakNet::RakPeerInterface::GetSystemAddressFromIndex           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>index</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
This function is only useful for looping through all systems Given an index, will return a <a class="el" href="structRakNet_1_1SystemAddress.html" title="Network address for a system.">SystemAddress</a>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>index</em>&nbsp;</td><td>Index should range between 0 and the maximum number of players allowed - 1. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The <a class="el" href="structRakNet_1_1SystemAddress.html" title="Network address for a system.">SystemAddress</a> </dd></dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#b5b6032519a2a12a2a61e3720b2ec3b2">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="a1939c66f7190e3c647a6a685a6eb248"></a><!-- doxytag: member="RakNet::RakPeerInterface::GetSystemList" ref="a1939c66f7190e3c647a6a685a6eb248" args="(DataStructures::List&lt; SystemAddress &gt; &amp;addresses, DataStructures::List&lt; RakNetGUID &gt; &amp;guids) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakNet::RakPeerInterface::GetSystemList           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDataStructures_1_1List.html">DataStructures::List</a>&lt; <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>addresses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classDataStructures_1_1List.html">DataStructures::List</a>&lt; <a class="el" href="structRakNet_1_1RakNetGUID.html">RakNetGUID</a> &gt; &amp;&nbsp;</td>
          <td class="paramname"> <em>guids</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as calling GetSystemAddressFromIndex and GetGUIDFromIndex for all systems, but more efficient Indices match each other, so <em>addresses</em>[0] and <em>guids</em>[0] refer to the same system <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>addresses</em>&nbsp;</td><td>All system addresses. Size of the list is the number of connections. Size of the list will match the size of the <em>guids</em> list. </td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>guids</em>&nbsp;</td><td>All guids. Size of the list is the number of connections. Size of the list will match the size of the <em>addresses</em> list. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#791779bb9714e830f19a5f12961576d7">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="0fd3a4d282327944ee50b00c79baf420"></a><!-- doxytag: member="RakNet::RakPeerInterface::GetTimeoutTime" ref="0fd3a4d282327944ee50b00c79baf420" args="(const SystemAddress target)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual RakNet::TimeMS RakNet::RakPeerInterface::GetTimeoutTime           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>target</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>target</em>&nbsp;</td><td>Which system to do this for. Pass UNASSIGNED_SYSTEM_ADDRESS to get the default value </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>timeoutTime for a given system. </dd></dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#12dc51372f2a5a109f3c6a55ba799763">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="9a406f292a6c44f551e9d8606992558e"></a><!-- doxytag: member="RakNet::RakPeerInterface::IncrementNextSendReceipt" ref="9a406f292a6c44f551e9d8606992558e" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t RakNet::RakPeerInterface::IncrementNextSendReceipt           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the next uint32_t that <a class="el" href="classRakNet_1_1RakPeerInterface.html#543ec5be9cf5f73f5c8733d1829789f9">Send()</a> will return, and increments the value by one <dl class="note" compact><dt><b>Note:</b></dt><dd>If using <a class="el" href="classRakNet_1_1RakPeer.html" title="Main interface for network communications.">RakPeer</a> from multiple threads, pass this to forceReceipt in the send function </dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The next uint32_t that <a class="el" href="classRakNet_1_1RakPeerInterface.html#543ec5be9cf5f73f5c8733d1829789f9">Send()</a> or SendList will return </dd></dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#9232bd1bc9c1a223ecef8682133f95ac">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="b5389821efb5d09470f8429925766eb3"></a><!-- doxytag: member="RakNet::RakPeerInterface::InitializeSecurity" ref="b5389821efb5d09470f8429925766eb3" args="(const char *publicKey, const char *privateKey, bool bRequireClientKey=false)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool RakNet::RakPeerInterface::InitializeSecurity           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>publicKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>privateKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>bRequireClientKey</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If you accept connections, you must call this or else security will not be enabled for incoming connections. This feature requires more round trips, bandwidth, and CPU time for the connection handshake x64 builds require under 25% of the CPU time of other builds See the Encryption sample for example usage <dl class="pre" compact><dt><b>Precondition:</b></dt><dd>Must be called while offline <p>
LIBCAT_SECURITY must be defined to 1 in NativeFeatureIncludes.h for this function to have any effect </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>publicKey</em>&nbsp;</td><td>A pointer to the public key for accepting new connections </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>privateKey</em>&nbsp;</td><td>A pointer to the private key for accepting new connections </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bRequireClientKey,:</em>&nbsp;</td><td>Should be set to false for most servers. Allows the server to accept a public key from connecting clients as a proof of identity but eats twice as much CPU time as a normal connection </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#5445d0e8db3e7ef1e38b7fc5bc0d3920">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="ffcba03406b89157976cf0e6a8924d66"></a><!-- doxytag: member="RakNet::RakPeerInterface::IsActive" ref="ffcba03406b89157976cf0e6a8924d66" args="(void) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool RakNet::RakPeerInterface::IsActive           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns if the network thread is running <dl class="return" compact><dt><b>Returns:</b></dt><dd>true if the network thread is running, false otherwise </dd></dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#e6bb2c4de0b24283b231154d29304e00">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="e28629f202de81ad4816470cd0f8fd94"></a><!-- doxytag: member="RakNet::RakPeerInterface::IsBanned" ref="e28629f202de81ad4816470cd0f8fd94" args="(const char *IP)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool RakNet::RakPeerInterface::IsBanned           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>IP</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true or false indicating if a particular IP is banned. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>IP</em>&nbsp;</td><td>- Dotted IP address. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if IP matches any IPs in the ban list, accounting for any wildcards. False otherwise. </dd></dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#499626110e1409b09e7d955722c4c3fd">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="2672cee4147e50818769e3573fb5c459"></a><!-- doxytag: member="RakNet::RakPeerInterface::IsInSecurityExceptionList" ref="2672cee4147e50818769e3573fb5c459" args="(const char *ip)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool RakNet::RakPeerInterface::IsInSecurityExceptionList           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ip</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks to see if a given IP is in the security exception list <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>IP</em>&nbsp;</td><td>address to check. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#654c29f6f195b0dcd105a856c99222d1">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="c37fe2c8b35abdc3a441541e539ebd10"></a><!-- doxytag: member="RakNet::RakPeerInterface::IsLocalIP" ref="c37fe2c8b35abdc3a441541e539ebd10" args="(const char *ip)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool RakNet::RakPeerInterface::IsLocalIP           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ip</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Is this a local IP? <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>An</em>&nbsp;</td><td>IP address to check, excluding the port </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True if this is one of the IP addresses returned by GetLocalIP </dd></dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#d89d80f939408a620a5e41eeab0a588a">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="917c367bcba491fb243161025b6eab01"></a><!-- doxytag: member="RakNet::RakPeerInterface::IsNetworkSimulatorActive" ref="917c367bcba491fb243161025b6eab01" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool RakNet::RakPeerInterface::IsNetworkSimulatorActive           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns if you previously called ApplyNetworkSimulator <dl class="return" compact><dt><b>Returns:</b></dt><dd>If you previously called ApplyNetworkSimulator </dd></dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#dc9c2b58a0970b6a80e50b1ecf470e43">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="88611e451f6f6e0d5f7cb00ce5bcabf9"></a><!-- doxytag: member="RakNet::RakPeerInterface::NumberOfConnections" ref="88611e451f6f6e0d5f7cb00ce5bcabf9" args="(void) const =0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned short RakNet::RakPeerInterface::NumberOfConnections           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns how many open connections there are at this time <dl class="return" compact><dt><b>Returns:</b></dt><dd>the number of open connections </dd></dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#4d47b849ba6e7ecf2d1fca3198a60ba5">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="d5667c9d47585be3a65485f9c81f7045"></a><!-- doxytag: member="RakNet::RakPeerInterface::Ping" ref="d5667c9d47585be3a65485f9c81f7045" args="(const char *host, unsigned short remotePort, bool onlyReplyOnAcceptingConnections, unsigned connectionSocketIndex=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool RakNet::RakPeerInterface::Ping           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>remotePort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>onlyReplyOnAcceptingConnections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>connectionSocketIndex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send a ping to the specified unconnected system. The remote system, if it is Initialized, will respond with ID_PONG followed by sizeof(RakNet::TimeMS) containing the system time the ping was sent.(Default is 4 bytes - See __GET_TIME_64BIT in <a class="el" href="RakNetTypes_8h.html" title="Types used by RakNet, most of which involve user code.">RakNetTypes.h</a> System should reply with ID_PONG if it is active <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>host</em>&nbsp;</td><td>Either a dotted IP address or a domain name. Can be 255.255.255.255 for LAN broadcast. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>remotePort</em>&nbsp;</td><td>Which port to connect to on the remote machine. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>onlyReplyOnAcceptingConnections</em>&nbsp;</td><td>Only request a reply if the remote system is accepting connections </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>connectionSocketIndex</em>&nbsp;</td><td>Index into the array of socket descriptors passed to socketDescriptors in <a class="el" href="classRakNet_1_1RakPeer.html#de24b8bf50eb756f54a208c2841f5e0d" title="Starts the network threads and opens the listen port.">RakPeer::Startup()</a> to send on. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true on success, false on failure (unknown hostname) </dd></dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#f7dd13a4c3d38e65bf816a604c6042c7">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="49dbff7ab8f516361e3d05645c2b7901"></a><!-- doxytag: member="RakNet::RakPeerInterface::Ping" ref="49dbff7ab8f516361e3d05645c2b7901" args="(const SystemAddress target)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakNet::RakPeerInterface::Ping           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>target</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send a ping to the specified connected system. <dl class="pre" compact><dt><b>Precondition:</b></dt><dd>The sender and recipient must already be started via a successful call to <a class="el" href="classRakNet_1_1RakPeerInterface.html#3c8c414844a87707c28cdf35f41a5f00" title="Starts the network threads, opens the listen port.">Startup()</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>target</em>&nbsp;</td><td>Which system to ping </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#9bb94828e0ad89e0d6c44a671bf22f8d">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="29c5527b07a3ddc32083d8ec1e24318b"></a><!-- doxytag: member="RakNet::RakPeerInterface::PushBackPacket" ref="29c5527b07a3ddc32083d8ec1e24318b" args="(Packet *packet, bool pushAtHead)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakNet::RakPeerInterface::PushBackPacket           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRakNet_1_1Packet.html">Packet</a> *&nbsp;</td>
          <td class="paramname"> <em>packet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>pushAtHead</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Put a message back at the end of the receive queue in case you don't want to deal with it immediately <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>packet</em>&nbsp;</td><td>The packet you want to push back. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>pushAtHead</em>&nbsp;</td><td>True to push the packet so that the next receive call returns it. False to push it at the end of the queue (obviously pushing it at the end makes the packets out of order) </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#c32f687f4bbd396e326be77ac1fa77a8">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="1c50453d9dee600920aeabd62ad7c119"></a><!-- doxytag: member="RakNet::RakPeerInterface::Receive" ref="1c50453d9dee600920aeabd62ad7c119" args="(void)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structRakNet_1_1Packet.html">Packet</a>* RakNet::RakPeerInterface::Receive           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets a message from the incoming message queue. Use <a class="el" href="classRakNet_1_1RakPeerInterface.html#21b929aba61ce69aab32871db33d6ede">DeallocatePacket()</a> to deallocate the message after you are done with it. User-thread functions, such as RPC calls and the plugin function PluginInterface::Update occur here. <dl class="return" compact><dt><b>Returns:</b></dt><dd>0 if no packets are waiting to be handled, otherwise a pointer to a packet. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>COMMON MISTAKE: Be sure to call this in a loop, once per game tick, until it returns 0. If you only process one packet per game tick they will buffer up. sa <a class="el" href="RakNetTypes_8h.html" title="Types used by RakNet, most of which involve user code.">RakNetTypes.h</a> contains struct <a class="el" href="structRakNet_1_1Packet.html" title="This represents a user message from another system.">Packet</a> </dd></dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#46d90fb903e747f76d63eb3a96543740">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="9e18c8dae14157432ddc6f19a8114c1b"></a><!-- doxytag: member="RakNet::RakPeerInterface::RemoveFromBanList" ref="9e18c8dae14157432ddc6f19a8114c1b" args="(const char *IP)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakNet::RakPeerInterface::RemoveFromBanList           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>IP</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Allows a previously banned IP to connect. param[in] Dotted IP address. Can use * as a wildcard, such as 128.0.0.* will banAll IP addresses starting with 128.0.0 
<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#86c426318efc45345df9a348ae822f34">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="8eba6b20dcba02453d1ed2ad77499f7d"></a><!-- doxytag: member="RakNet::RakPeerInterface::RemoveFromSecurityExceptionList" ref="8eba6b20dcba02453d1ed2ad77499f7d" args="(const char *ip)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakNet::RakPeerInterface::RemoveFromSecurityExceptionList           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>ip</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Remove a specific connection previously added via AddToSecurityExceptionList <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>ip</em>&nbsp;</td><td>IP address to remove. Pass 0 to remove all IP addresses. * wildcards are supported. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#931823b7400d31ad641d6f6da1e69b88">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="6d9a5415556a9c138854cc05c707b8e7"></a><!-- doxytag: member="RakNet::RakPeerInterface::Send" ref="6d9a5415556a9c138854cc05c707b8e7" args="(const RakNet::BitStream *bitStream, PacketPriority priority, PacketReliability reliability, char orderingChannel, const AddressOrGUID systemIdentifier, bool broadcast, uint32_t forceReceiptNumber=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t RakNet::RakPeerInterface::Send           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> *&nbsp;</td>
          <td class="paramname"> <em>bitStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a>&nbsp;</td>
          <td class="paramname"> <em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PacketPriority_8h.html#e41fa01235e99dced384d137fa874a7e">PacketReliability</a>&nbsp;</td>
          <td class="paramname"> <em>reliability</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>orderingChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AddressOrGUID&nbsp;</td>
          <td class="paramname"> <em>systemIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>broadcast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>forceReceiptNumber</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sends a block of data to the specified system that you are connected to. Same as the above version, but takes a <a class="el" href="classRakNet_1_1BitStream.html">BitStream</a> as input. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>bitStream</em>&nbsp;</td><td>The bitstream to send </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>priority</em>&nbsp;</td><td>What priority level to send on. See <a class="el" href="PacketPriority_8h.html" title="This file contains enumerations for packet priority and reliability enumerations...">PacketPriority.h</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reliability</em>&nbsp;</td><td>How reliability to send this data. See <a class="el" href="PacketPriority_8h.html" title="This file contains enumerations for packet priority and reliability enumerations...">PacketPriority.h</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>orderingChannel</em>&nbsp;</td><td>When using ordered or sequenced messages, what channel to order these on. Messages are only ordered relative to other messages on the same stream </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemIdentifier</em>&nbsp;</td><td>Who to send this packet to, or in the case of broadcasting who not to send it to. Pass either a <a class="el" href="structRakNet_1_1SystemAddress.html" title="Network address for a system.">SystemAddress</a> structure or a <a class="el" href="structRakNet_1_1RakNetGUID.html">RakNetGUID</a> structure. Use UNASSIGNED_SYSTEM_ADDRESS or to specify none </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>broadcast</em>&nbsp;</td><td>True to send this packet to all connected systems. If true, then systemAddress specifies who not to send the packet to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>forceReceipt</em>&nbsp;</td><td>If 0, will automatically determine the receipt number to return. If non-zero, will return what you give it. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on bad input. Otherwise a number that identifies this message. If <em>reliability</em> is a type that returns a receipt, on a later call to <a class="el" href="classRakNet_1_1RakPeerInterface.html#1c50453d9dee600920aeabd62ad7c119">Receive()</a> you will get ID_SND_RECEIPT_ACKED or ID_SND_RECEIPT_LOSS with bytes 1-4 inclusive containing this number </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>COMMON MISTAKE: When writing the first byte, bitStream-&gt;Write((unsigned char) ID_MY_TYPE) be sure it is casted to a byte, and you are not writing a 4 byte enumeration. </dd></dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#c308204d9c3f5f92ac11b30f1d183d4b">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="543ec5be9cf5f73f5c8733d1829789f9"></a><!-- doxytag: member="RakNet::RakPeerInterface::Send" ref="543ec5be9cf5f73f5c8733d1829789f9" args="(const char *data, const int length, PacketPriority priority, PacketReliability reliability, char orderingChannel, const AddressOrGUID systemIdentifier, bool broadcast, uint32_t forceReceiptNumber=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t RakNet::RakPeerInterface::Send           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a>&nbsp;</td>
          <td class="paramname"> <em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PacketPriority_8h.html#e41fa01235e99dced384d137fa874a7e">PacketReliability</a>&nbsp;</td>
          <td class="paramname"> <em>reliability</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>orderingChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AddressOrGUID&nbsp;</td>
          <td class="paramname"> <em>systemIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>broadcast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>forceReceiptNumber</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sends a block of data to the specified system that you are connected to. This function only works while the connected The first byte should be a message identifier starting at ID_USER_PACKET_ENUM <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>The block of data to send </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>The size in bytes of the data to send </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>priority</em>&nbsp;</td><td>What priority level to send on. See <a class="el" href="PacketPriority_8h.html" title="This file contains enumerations for packet priority and reliability enumerations...">PacketPriority.h</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reliability</em>&nbsp;</td><td>How reliability to send this data. See <a class="el" href="PacketPriority_8h.html" title="This file contains enumerations for packet priority and reliability enumerations...">PacketPriority.h</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>orderingChannel</em>&nbsp;</td><td>When using ordered or sequenced messages, what channel to order these on. Messages are only ordered relative to other messages on the same stream </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemIdentifier</em>&nbsp;</td><td>Who to send this packet to, or in the case of broadcasting who not to send it to. Pass either a <a class="el" href="structRakNet_1_1SystemAddress.html" title="Network address for a system.">SystemAddress</a> structure or a <a class="el" href="structRakNet_1_1RakNetGUID.html">RakNetGUID</a> structure. Use UNASSIGNED_SYSTEM_ADDRESS or to specify none </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>broadcast</em>&nbsp;</td><td>True to send this packet to all connected systems. If true, then systemAddress specifies who not to send the packet to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>forceReceipt</em>&nbsp;</td><td>If 0, will automatically determine the receipt number to return. If non-zero, will return what you give it. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on bad input. Otherwise a number that identifies this message. If <em>reliability</em> is a type that returns a receipt, on a later call to <a class="el" href="classRakNet_1_1RakPeerInterface.html#1c50453d9dee600920aeabd62ad7c119">Receive()</a> you will get ID_SND_RECEIPT_ACKED or ID_SND_RECEIPT_LOSS with bytes 1-4 inclusive containing this number </dd></dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#1ee7422f744ab606c92b4ed4b28db40e">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="508111f60de06beb55a65a2b811d557c"></a><!-- doxytag: member="RakNet::RakPeerInterface::SendList" ref="508111f60de06beb55a65a2b811d557c" args="(const char **data, const int *lengths, const int numParameters, PacketPriority priority, PacketReliability reliability, char orderingChannel, const AddressOrGUID systemIdentifier, bool broadcast, uint32_t forceReceiptNumber=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t RakNet::RakPeerInterface::SendList           </td>
          <td>(</td>
          <td class="paramtype">const char **&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&nbsp;</td>
          <td class="paramname"> <em>lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>numParameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a>&nbsp;</td>
          <td class="paramname"> <em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PacketPriority_8h.html#e41fa01235e99dced384d137fa874a7e">PacketReliability</a>&nbsp;</td>
          <td class="paramname"> <em>reliability</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&nbsp;</td>
          <td class="paramname"> <em>orderingChannel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AddressOrGUID&nbsp;</td>
          <td class="paramname"> <em>systemIdentifier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>broadcast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&nbsp;</td>
          <td class="paramname"> <em>forceReceiptNumber</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sends multiple blocks of data, concatenating them automatically.<p>
This is equivalent to: <a class="el" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> bs; bs.WriteAlignedBytes(block1, blockLength1); bs.WriteAlignedBytes(block2, blockLength2); bs.WriteAlignedBytes(block3, blockLength3); Send(&amp;bs, ...)<p>
This function only works while the connected <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>An array of pointers to blocks of data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lengths</em>&nbsp;</td><td>An array of integers indicating the length of each block of data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numParameters</em>&nbsp;</td><td>Length of the arrays data and lengths </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>priority</em>&nbsp;</td><td>What priority level to send on. See <a class="el" href="PacketPriority_8h.html" title="This file contains enumerations for packet priority and reliability enumerations...">PacketPriority.h</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>reliability</em>&nbsp;</td><td>How reliability to send this data. See <a class="el" href="PacketPriority_8h.html" title="This file contains enumerations for packet priority and reliability enumerations...">PacketPriority.h</a> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>orderingChannel</em>&nbsp;</td><td>When using ordered or sequenced messages, what channel to order these on. Messages are only ordered relative to other messages on the same stream </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>systemIdentifier</em>&nbsp;</td><td>Who to send this packet to, or in the case of broadcasting who not to send it to. Pass either a <a class="el" href="structRakNet_1_1SystemAddress.html" title="Network address for a system.">SystemAddress</a> structure or a <a class="el" href="structRakNet_1_1RakNetGUID.html">RakNetGUID</a> structure. Use UNASSIGNED_SYSTEM_ADDRESS or to specify none </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>broadcast</em>&nbsp;</td><td>True to send this packet to all connected systems. If true, then systemAddress specifies who not to send the packet to. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>forceReceipt</em>&nbsp;</td><td>If 0, will automatically determine the receipt number to return. If non-zero, will return what you give it. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>0 on bad input. Otherwise a number that identifies this message. If <em>reliability</em> is a type that returns a receipt, on a later call to <a class="el" href="classRakNet_1_1RakPeerInterface.html#1c50453d9dee600920aeabd62ad7c119">Receive()</a> you will get ID_SND_RECEIPT_ACKED or ID_SND_RECEIPT_LOSS with bytes 1-4 inclusive containing this number </dd></dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#68a9c6f4db253074f3775d164e39195f">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="b8e39273dd7fb89d4b29a01bca32f82c"></a><!-- doxytag: member="RakNet::RakPeerInterface::SendLoopback" ref="b8e39273dd7fb89d4b29a01bca32f82c" args="(const char *data, const int length)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakNet::RakPeerInterface::SendLoopback           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
"Send" to yourself rather than a remote system. The message will be processed through the plugins and returned to the game as usual This function works anytime The first byte should be a message identifier starting at ID_USER_PACKET_ENUM <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>The block of data to send </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>The size in bytes of the data to send </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#c3f1dcedc63156184962aa184ba69ed2">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="700a2c9bc1414da194a35076af3b56e0"></a><!-- doxytag: member="RakNet::RakPeerInterface::SendTTL" ref="700a2c9bc1414da194a35076af3b56e0" args="(const char *host, unsigned short remotePort, int ttl, unsigned connectionSocketIndex=0)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakNet::RakPeerInterface::SendTTL           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>remotePort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ttl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>connectionSocketIndex</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Send a message to host, with the IP socket option TTL set to 3 This message will not reach the host, but will open the router. Used for NAT-Punchthrough 
<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#86b8b2a8d2e4edc2c1d89f6bde8b9f28">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="d18a28a99420006d020125eea1ded4ed"></a><!-- doxytag: member="RakNet::RakPeerInterface::SetIncomingPassword" ref="d18a28a99420006d020125eea1ded4ed" args="(const char *passwordData, int passwordDataLength)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakNet::RakPeerInterface::SetIncomingPassword           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>passwordData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>passwordDataLength</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the password incoming connections must match in the call to Connect (defaults to none). Pass 0 to passwordData to specify no password This is a way to set a low level password for all incoming connections. To selectively reject connections, implement your own scheme using <a class="el" href="classRakNet_1_1RakPeerInterface.html#fd637c6f44cb84ce5c151c700bb5cafe">CloseConnection()</a> to remove unwanted connections <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>passwordData</em>&nbsp;</td><td>A data block that incoming connections must match. This can be just a password, or can be a stream of data. Specify 0 for no password data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>passwordDataLength</em>&nbsp;</td><td>The length in bytes of passwordData </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#6d4071bbbf128604c94a27c46fa7b9ce">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="1c7d098a1d9a4613f051ae3627831af6"></a><!-- doxytag: member="RakNet::RakPeerInterface::SetLimitIPConnectionFrequency" ref="1c7d098a1d9a4613f051ae3627831af6" args="(bool b)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakNet::RakPeerInterface::SetLimitIPConnectionFrequency           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>b</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enable or disable allowing frequent connections from the same IP adderss This is a security measure which is disabled by default, but can be set to true to prevent attackers from using up all connection slots <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>b</em>&nbsp;</td><td>True to limit connections from the same ip to at most 1 per 100 milliseconds. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#c5e80ab105ac8124d4ee5f94bd1b316a">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="1f279ee0d3578de483126f6cfef282f4"></a><!-- doxytag: member="RakNet::RakPeerInterface::SetMaximumIncomingConnections" ref="1f279ee0d3578de483126f6cfef282f4" args="(unsigned short numberAllowed)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakNet::RakPeerInterface::SetMaximumIncomingConnections           </td>
          <td>(</td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>numberAllowed</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets how many incoming connections are allowed. If this is less than the number of players currently connected, no more players will be allowed to connect. If this is greater than the maximum number of peers allowed, it will be reduced to the maximum number of peers allowed. Defaults to 0, meaning by default, nobody can connect to you <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numberAllowed</em>&nbsp;</td><td>Maximum number of incoming connections allowed. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#8ed81856dd81ec1cd00e17fafedee0a7">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="fdc6e658512d2f01d6bb211758721f21"></a><!-- doxytag: member="RakNet::RakPeerInterface::SetOccasionalPing" ref="fdc6e658512d2f01d6bb211758721f21" args="(bool doPing)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakNet::RakPeerInterface::SetOccasionalPing           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>doPing</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Ping the remote systems every so often, or not. Can be called anytime. By default this is true. Recommended to leave on, because congestion control uses it to determine how often to resend lost packets. It would be true by default to prevent timestamp drift, since in the event of a clock spike, the timestamp deltas would no longer be accurate <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>doPing</em>&nbsp;</td><td>True to start occasional pings. False to stop them. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#bb8d47e41f9bc523a555d8f1bc774e4a">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="40b198325a1a4f4a1ff3b1a1741b89eb"></a><!-- doxytag: member="RakNet::RakPeerInterface::SetOfflinePingResponse" ref="40b198325a1a4f4a1ff3b1a1741b89eb" args="(const char *data, const unsigned int length)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakNet::RakPeerInterface::SetOfflinePingResponse           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&nbsp;</td>
          <td class="paramname"> <em>length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the data to send along with a LAN server discovery or offline ping reply. <em>length</em> should be under 400 bytes, as a security measure against flood attacks <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>data</em>&nbsp;</td><td>a block of data to store, or 0 for none </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>length</em>&nbsp;</td><td>The length of data in bytes, or 0 for none </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd>Ping.cpp </dd></dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#2a534f1c0bb56b3c5b9b56ca8839917c">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="95daeb743853a4406182e47668c0f33b"></a><!-- doxytag: member="RakNet::RakPeerInterface::SetPerConnectionOutgoingBandwidthLimit" ref="95daeb743853a4406182e47668c0f33b" args="(unsigned maxBitsPerSecond)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakNet::RakPeerInterface::SetPerConnectionOutgoingBandwidthLimit           </td>
          <td>(</td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>maxBitsPerSecond</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Limits how much outgoing bandwidth can be sent per-connection. This limit does not apply to the sum of all connections! Exceeding the limit queues up outgoing traffic <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxBitsPerSecond</em>&nbsp;</td><td>Maximum bits per second to send. Use 0 for unlimited (default). Once set, it takes effect immedately and persists until called again. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#9c67c61c6eebed7a4ed8bc2ea2813b56">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="4112544503b05a7b7dd2dd56adfbc648"></a><!-- doxytag: member="RakNet::RakPeerInterface::SetSplitMessageProgressInterval" ref="4112544503b05a7b7dd2dd56adfbc648" args="(int interval)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakNet::RakPeerInterface::SetSplitMessageProgressInterval           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>interval</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Controls how often to return ID_DOWNLOAD_PROGRESS for large message downloads. ID_DOWNLOAD_PROGRESS is returned to indicate a new partial message chunk, roughly the MTU size, has arrived As it can be slow or cumbersome to get this notification for every chunk, you can set the interval at which it is returned. Defaults to 0 (never return this notification) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>interval</em>&nbsp;</td><td>How many messages to use as an interval </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#35e89d9813d6f6e7f2144a6a0437a33b">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="49d2993d5db12a62ce88dc89700c0880"></a><!-- doxytag: member="RakNet::RakPeerInterface::SetTimeoutTime" ref="49d2993d5db12a62ce88dc89700c0880" args="(RakNet::TimeMS timeMS, const SystemAddress target)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakNet::RakPeerInterface::SetTimeoutTime           </td>
          <td>(</td>
          <td class="paramtype">RakNet::TimeMS&nbsp;</td>
          <td class="paramname"> <em>timeMS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a>&nbsp;</td>
          <td class="paramname"> <em>target</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set the time, in MS, to use before considering ourselves disconnected after not being able to deliver a reliable message. Default time is 10,000 or 10 seconds in release and 30,000 or 30 seconds in debug. Do not set different values for different computers that are connected to each other, or you won't be able to reconnect after ID_CONNECTION_LOST <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeMS</em>&nbsp;</td><td>Time, in MS </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>target</em>&nbsp;</td><td>Which system to do this for. Pass UNASSIGNED_SYSTEM_ADDRESS for all systems. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#46305b16342c6f5ec1c1a66623032310">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="87db4b6410fce078080400f8d58328ed"></a><!-- doxytag: member="RakNet::RakPeerInterface::SetUnreliableTimeout" ref="87db4b6410fce078080400f8d58328ed" args="(RakNet::TimeMS timeoutMS)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakNet::RakPeerInterface::SetUnreliableTimeout           </td>
          <td>(</td>
          <td class="paramtype">RakNet::TimeMS&nbsp;</td>
          <td class="paramname"> <em>timeoutMS</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Set how long to wait before giving up on sending an unreliable message Useful if the network is clogged up. Set to 0 or less to never timeout. Defaults to 0. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>timeoutMS</em>&nbsp;</td><td>How many ms to wait before simply not sending an unreliable message. </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#739faf1ea8c90aded5e11bfc105b956e">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="0832004c529aa9a0844b61eaf1374b3c"></a><!-- doxytag: member="RakNet::RakPeerInterface::SetUserUpdateThread" ref="0832004c529aa9a0844b61eaf1374b3c" args="(void(*_userUpdateThreadPtr)(RakPeerInterface *, void *), void *_userUpdateThreadData)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakNet::RakPeerInterface::SetUserUpdateThread           </td>
          <td>(</td>
          <td class="paramtype">void(*)(<a class="el" href="classRakNet_1_1RakPeerInterface.html">RakPeerInterface</a> *, void *)&nbsp;</td>
          <td class="paramname"> <em>_userUpdateThreadPtr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>_userUpdateThreadData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
If you need code to run in the same thread as RakNet's update thread, this function can be used for that <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>_userUpdateThreadPtr</em>&nbsp;</td><td>C callback function </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>_userUpdateThreadData</em>&nbsp;</td><td>Passed to C callback function </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#21f59d33d16332dd8dd96d800c33d06e">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="4f4acefdc022555862fd386e31f9a22b"></a><!-- doxytag: member="RakNet::RakPeerInterface::Shutdown" ref="4f4acefdc022555862fd386e31f9a22b" args="(unsigned int blockDuration, unsigned char orderingChannel=0, PacketPriority disconnectionNotificationPriority=LOW_PRIORITY)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual void RakNet::RakPeerInterface::Shutdown           </td>
          <td>(</td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>blockDuration</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&nbsp;</td>
          <td class="paramname"> <em>orderingChannel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="PacketPriority_8h.html#659378374e516180f93640c79f59705c">PacketPriority</a>&nbsp;</td>
          <td class="paramname"> <em>disconnectionNotificationPriority</em> = <code>LOW_PRIORITY</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Connect to the specified network ID (Platform specific console function). 
<p>
Does built-in NAt traversal <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>passwordData</em>&nbsp;</td><td>A data block that must match the data block on the server passed to SetIncomingPassword. This can be a string or can be a stream of data. Use 0 for no password. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>passwordDataLength</em>&nbsp;</td><td>The length in bytes of passwordData Stops the network threads and closes all connections. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>blockDuration</em>&nbsp;</td><td>How long, in milliseconds, you should wait for all remaining messages to go out, including ID_DISCONNECTION_NOTIFICATION. If 0, it doesn't wait at all. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>orderingChannel</em>&nbsp;</td><td>If blockDuration &gt; 0, ID_DISCONNECTION_NOTIFICATION will be sent on this channel </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>disconnectionNotificationPriority</em>&nbsp;</td><td>Priority to send ID_DISCONNECTION_NOTIFICATION on. If you set it to 0 then the disconnection notification won't be sent </td></tr>
  </table>
</dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#0a6d4c16c9b489574393a39ab2f99990">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<a class="anchor" name="3c8c414844a87707c28cdf35f41a5f00"></a><!-- doxytag: member="RakNet::RakPeerInterface::Startup" ref="3c8c414844a87707c28cdf35f41a5f00" args="(unsigned short maxConnections, SocketDescriptor *socketDescriptors, unsigned socketDescriptorCount, int threadPriority=&#45;99999)=0" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">virtual StartupResult RakNet::RakPeerInterface::Startup           </td>
          <td>(</td>
          <td class="paramtype">unsigned short&nbsp;</td>
          <td class="paramname"> <em>maxConnections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structRakNet_1_1SocketDescriptor.html">SocketDescriptor</a> *&nbsp;</td>
          <td class="paramname"> <em>socketDescriptors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&nbsp;</td>
          <td class="paramname"> <em>socketDescriptorCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>threadPriority</em> = <code>-99999</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [pure virtual]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Starts the network threads, opens the listen port. 
<p>
You must call this before calling <a class="el" href="classRakNet_1_1RakPeerInterface.html#451dd5d225277fe5806d3d700551fb76" title="Connect to the specified host (ip or domain name) and server port. Calling Connect...">Connect()</a>. <dl class="pre" compact><dt><b>Precondition:</b></dt><dd>On the PS3, call <a class="el" href="classRakNet_1_1RakPeerInterface.html#3c8c414844a87707c28cdf35f41a5f00" title="Starts the network threads, opens the listen port.">Startup()</a> after Client_Login() <p>
On Android, add the necessary permission to your application's androidmanifest.xml: &lt;uses-permission android:name="android.permission.INTERNET" /&gt; Multiple calls while already active are ignored. To call this function again with different settings, you must first call <a class="el" href="classRakNet_1_1RakPeerInterface.html#4f4acefdc022555862fd386e31f9a22b" title="Connect to the specified network ID (Platform specific console function).">Shutdown()</a>. </dd></dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Call SetMaximumIncomingConnections if you want to accept incoming connections </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxConnections</em>&nbsp;</td><td>The maximum number of connections between this instance of <a class="el" href="classRakNet_1_1RakPeer.html" title="Main interface for network communications.">RakPeer</a> and another instance of <a class="el" href="classRakNet_1_1RakPeer.html" title="Main interface for network communications.">RakPeer</a>. Required so the network can preallocate and for thread safety. A pure client would set this to 1. A pure server would set it to the number of allowed clients.- A hybrid would set it to the sum of both types of connections </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>localPort</em>&nbsp;</td><td>The port to listen for connections on. On linux the system may be set up so thast ports under 1024 are restricted for everything but the root user. Use a higher port for maximum compatibility. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>socketDescriptors</em>&nbsp;</td><td>An array of <a class="el" href="structRakNet_1_1SocketDescriptor.html" title="Describes the local socket to use for RakPeer::Startup.">SocketDescriptor</a> structures to force <a class="el" href="namespaceRakNet.html" title="Simple class to send changes between directories. In essence, a simple autopatcher...">RakNet</a> to listen on a particular IP address or port (or both). Each <a class="el" href="structRakNet_1_1SocketDescriptor.html" title="Describes the local socket to use for RakPeer::Startup.">SocketDescriptor</a> will represent one unique socket. Do not pass redundant structures. To listen on a specific port, you can pass SocketDescriptor(myPort,0); such as for a server. For a client, it is usually OK to just pass SocketDescriptor(); However, on the XBOX be sure to use IPPROTO_VDP </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>socketDescriptorCount</em>&nbsp;</td><td>The size of the <em>socketDescriptors</em> array. Pass 1 if you are not sure what to pass. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>threadPriority</em>&nbsp;</td><td>Passed to the thread creation routine. Use THREAD_PRIORITY_NORMAL for Windows. For Linux based systems, you MUST pass something reasonable based on the thread priorities for your application. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>RAKNET_STARTED on success, otherwise appropriate failure enumeration. </dd></dl>

<p>Implemented in <a class="el" href="classRakNet_1_1RakPeer.html#de24b8bf50eb756f54a208c2841f5e0d">RakNet::RakPeer</a>.</p>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>d:/temp/RakNet_PC/Source/<a class="el" href="RakPeerInterface_8h.html">RakPeerInterface.h</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Feb 1 13:33:48 2012 for RakNet by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.7.1 </small></address>
</body>
</html>
