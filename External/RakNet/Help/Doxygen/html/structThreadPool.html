<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>RakNet: ThreadPool&lt; InputType, OutputType &gt; Struct Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>ThreadPool&lt; InputType, OutputType &gt; Struct Template Reference</h1><!-- doxytag: class="ThreadPool" --><code>#include &lt;ThreadPool.h&gt;</code>
<p>

<p>
<a href="structThreadPool-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#09fde0ca678340723840fae1dcda51a2">StartThreads</a> (int numThreads, int stackSize, void *(*_perThreadInit)()=0, void(*_perThreadDeinit)(void *)=0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d93b8ba41d96c5f0f814ae0acabfcdfc"></a><!-- doxytag: member="ThreadPool::StopThreads" ref="d93b8ba41d96c5f0f814ae0acabfcdfc" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#d93b8ba41d96c5f0f814ae0acabfcdfc">StopThreads</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stops all threads. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#5f64a8c4a4400106a2d7d03f7f9de132">AddInput</a> (OutputType(*workerThreadCallback)(InputType, bool *returnOutput, void *perThreadData), InputType inputData)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#833f8cc619dbf051c525c2ecd7ce78a0">AddOutput</a> (OutputType outputData)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#925d6c332e4c48bc99dc5750dfd5fcdd">HasOutput</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#5d517170f4b61211325ac5c9717e32e1">HasOutputFast</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#ac1ae43b7b3581b5ae9803c7cae7b724">HasInput</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#dde82517b452d9a74e91114a3783ce02">HasInputFast</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">OutputType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#568e3e2035977a38ad35aeee74ed7388">GetOutput</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f1e0cc5c3c8786fc49f60aef34160cbd"></a><!-- doxytag: member="ThreadPool::Clear" ref="f1e0cc5c3c8786fc49f60aef34160cbd" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#f1e0cc5c3c8786fc49f60aef34160cbd">Clear</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Clears internal buffers. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#024e2da38f846fc76d1fb16cf13c1b90">LockInput</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="710a554919e550501f9f06ab61e1d911"></a><!-- doxytag: member="ThreadPool::UnlockInput" ref="710a554919e550501f9f06ab61e1d911" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#710a554919e550501f9f06ab61e1d911">UnlockInput</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock the input buffer after you are done with the functions InputSize, GetInputAtIndex, and RemoveInputAtIndex. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0c7631f35a83c4f992b881174b6c8eff"></a><!-- doxytag: member="ThreadPool::InputSize" ref="0c7631f35a83c4f992b881174b6c8eff" args="(void)" -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#0c7631f35a83c4f992b881174b6c8eff">InputSize</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Length of the input queue. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="09194411e4f4d87804111459fad24522"></a><!-- doxytag: member="ThreadPool::GetInputAtIndex" ref="09194411e4f4d87804111459fad24522" args="(unsigned index)" -->
InputType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#09194411e4f4d87804111459fad24522">GetInputAtIndex</a> (unsigned index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the input at a specified index. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7e41bfe6660b1a55cbf14b99b77defac"></a><!-- doxytag: member="ThreadPool::RemoveInputAtIndex" ref="7e41bfe6660b1a55cbf14b99b77defac" args="(unsigned index)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#7e41bfe6660b1a55cbf14b99b77defac">RemoveInputAtIndex</a> (unsigned index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove input from a specific index. This does NOT do memory deallocation - it only removes the item from the queue. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#384ba5c62d60ac2e12e3f8aeea30d8bc">LockOutput</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f6e5208df0686a4a76ecb3bbcc6ffcb2"></a><!-- doxytag: member="ThreadPool::UnlockOutput" ref="f6e5208df0686a4a76ecb3bbcc6ffcb2" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#f6e5208df0686a4a76ecb3bbcc6ffcb2">UnlockOutput</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unlock the output buffer after you are done with the functions OutputSize, GetOutputAtIndex, and RemoveOutputAtIndex. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c2ebae170e7dbdbad6034ba69271f86f"></a><!-- doxytag: member="ThreadPool::OutputSize" ref="c2ebae170e7dbdbad6034ba69271f86f" args="(void)" -->
unsigned&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#c2ebae170e7dbdbad6034ba69271f86f">OutputSize</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Length of the output queue. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="de45848613e8230e5324edabe40fcde9"></a><!-- doxytag: member="ThreadPool::GetOutputAtIndex" ref="de45848613e8230e5324edabe40fcde9" args="(unsigned index)" -->
OutputType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#de45848613e8230e5324edabe40fcde9">GetOutputAtIndex</a> (unsigned index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Get the output at a specified index. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="fb4958a8df475d6060bede0fa4af7faa"></a><!-- doxytag: member="ThreadPool::RemoveOutputAtIndex" ref="fb4958a8df475d6060bede0fa4af7faa" args="(unsigned index)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#fb4958a8df475d6060bede0fa4af7faa">RemoveOutputAtIndex</a> (unsigned index)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Remove output from a specific index. This does NOT do memory deallocation - it only removes the item from the queue. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="568d636d8a27645c6641d3b4cc7308f6"></a><!-- doxytag: member="ThreadPool::ClearInput" ref="568d636d8a27645c6641d3b4cc7308f6" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#568d636d8a27645c6641d3b4cc7308f6">ClearInput</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all items from the input queue. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8d8d2d173ca5ddb99614ed5b9df1fb85"></a><!-- doxytag: member="ThreadPool::ClearOutput" ref="8d8d2d173ca5ddb99614ed5b9df1fb85" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#8d8d2d173ca5ddb99614ed5b9df1fb85">ClearOutput</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes all items from the output queue. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="90b37c13ba8b9f67db4bd99ee4a5d811"></a><!-- doxytag: member="ThreadPool::IsWorking" ref="90b37c13ba8b9f67db4bd99ee4a5d811" args="(void)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#90b37c13ba8b9f67db4bd99ee4a5d811">IsWorking</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Are any of the threads working, or is input or output available? <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ad431a8d3f28af0ae5249c7e3b819307"></a><!-- doxytag: member="ThreadPool::NumThreadsWorking" ref="ad431a8d3f28af0ae5249c7e3b819307" args="(void)" -->
int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#ad431a8d3f28af0ae5249c7e3b819307">NumThreadsWorking</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The number of currently active threads. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="531920221fd17dce38b5da74b56f2eff"></a><!-- doxytag: member="ThreadPool::WasStarted" ref="531920221fd17dce38b5da74b56f2eff" args="(void)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="structThreadPool.html#531920221fd17dce38b5da74b56f2eff">WasStarted</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Did we call Start? <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class InputType, class OutputType&gt;<br>
 struct ThreadPool&lt; InputType, OutputType &gt;</h3>

A simple class to create worker threads that processes a queue of functions with data. This class does not allocate or deallocate memory. It is up to the user to handle memory management. InputType and OutputType are stored directly in a queue. For large structures, if you plan to delete from the middle of the queue, you might wish to store pointers rather than the structures themselves so the array can shift efficiently. <hr><h2>Member Function Documentation</h2>
<a class="anchor" name="5f64a8c4a4400106a2d7d03f7f9de132"></a><!-- doxytag: member="ThreadPool::AddInput" ref="5f64a8c4a4400106a2d7d03f7f9de132" args="(OutputType(*workerThreadCallback)(InputType, bool *returnOutput, void *perThreadData), InputType inputData)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputType , class OutputType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structThreadPool.html">ThreadPool</a>&lt; InputType, OutputType &gt;::AddInput           </td>
          <td>(</td>
          <td class="paramtype">OutputType(*)(InputType, bool *returnOutput, void *perThreadData)&nbsp;</td>
          <td class="paramname"> <em>workerThreadCallback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputType&nbsp;</td>
          <td class="paramname"> <em>inputData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a function to a queue with data to pass to that function. This function will be called from the thread Memory management is your responsibility! This class does not allocate or deallocate memory. The best way to deallocate <em>inputData</em> is in userCallback. If you call EndThreads such that callbacks were not called, you can iterate through the inputQueue and deallocate all pending input data there The best way to deallocate output is as it is returned to you from GetOutput. Similarly, if you end the threads such that not all output was returned, you can iterate through outputQueue and deallocate it there. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>workerThreadCallback</em>&nbsp;</td><td>The function to call from the thread </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inputData</em>&nbsp;</td><td>The parameter to pass to <em>userCallback</em> </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="833f8cc619dbf051c525c2ecd7ce78a0"></a><!-- doxytag: member="ThreadPool::AddOutput" ref="833f8cc619dbf051c525c2ecd7ce78a0" args="(OutputType outputData)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputType , class OutputType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structThreadPool.html">ThreadPool</a>&lt; InputType, OutputType &gt;::AddOutput           </td>
          <td>(</td>
          <td class="paramtype">OutputType&nbsp;</td>
          <td class="paramname"> <em>outputData</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds to the output queue Use it if you want to inject output into the same queue that the system uses. Normally you would not use this. Consider it a convenience function. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>outputData</em>&nbsp;</td><td>The output to inject </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="568e3e2035977a38ad35aeee74ed7388"></a><!-- doxytag: member="ThreadPool::GetOutput" ref="568e3e2035977a38ad35aeee74ed7388" args="(void)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputType , class OutputType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OutputType <a class="el" href="structThreadPool.html">ThreadPool</a>&lt; InputType, OutputType &gt;::GetOutput           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the output of a call to <em>userCallback</em> HasOutput must return true before you call this function. Otherwise it will assert. <dl class="return" compact><dt><b>Returns:</b></dt><dd>The output of <em>userCallback</em>. If you have different output signatures, it is up to you to encode the data to indicate this </dd></dl>

</div>
</div><p>
<a class="anchor" name="ac1ae43b7b3581b5ae9803c7cae7b724"></a><!-- doxytag: member="ThreadPool::HasInput" ref="ac1ae43b7b3581b5ae9803c7cae7b724" args="(void)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputType , class OutputType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structThreadPool.html">ThreadPool</a>&lt; InputType, OutputType &gt;::HasInput           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if input from GetInput is waiting. <dl class="return" compact><dt><b>Returns:</b></dt><dd>true if input is waiting, false otherwise </dd></dl>

</div>
</div><p>
<a class="anchor" name="dde82517b452d9a74e91114a3783ce02"></a><!-- doxytag: member="ThreadPool::HasInputFast" ref="dde82517b452d9a74e91114a3783ce02" args="(void)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputType , class OutputType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structThreadPool.html">ThreadPool</a>&lt; InputType, OutputType &gt;::HasInputFast           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inaccurate but fast version of HasInput. If this returns true, you should still check HasInput for the real value. <dl class="return" compact><dt><b>Returns:</b></dt><dd>true if input is probably waiting, false otherwise </dd></dl>

</div>
</div><p>
<a class="anchor" name="925d6c332e4c48bc99dc5750dfd5fcdd"></a><!-- doxytag: member="ThreadPool::HasOutput" ref="925d6c332e4c48bc99dc5750dfd5fcdd" args="(void)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputType , class OutputType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structThreadPool.html">ThreadPool</a>&lt; InputType, OutputType &gt;::HasOutput           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if output from GetOutput is waiting. <dl class="return" compact><dt><b>Returns:</b></dt><dd>true if output is waiting, false otherwise </dd></dl>

</div>
</div><p>
<a class="anchor" name="5d517170f4b61211325ac5c9717e32e1"></a><!-- doxytag: member="ThreadPool::HasOutputFast" ref="5d517170f4b61211325ac5c9717e32e1" args="(void)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputType , class OutputType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structThreadPool.html">ThreadPool</a>&lt; InputType, OutputType &gt;::HasOutputFast           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Inaccurate but fast version of HasOutput. If this returns true, you should still check HasOutput for the real value. <dl class="return" compact><dt><b>Returns:</b></dt><dd>true if output is probably waiting, false otherwise </dd></dl>

</div>
</div><p>
<a class="anchor" name="024e2da38f846fc76d1fb16cf13c1b90"></a><!-- doxytag: member="ThreadPool::LockInput" ref="024e2da38f846fc76d1fb16cf13c1b90" args="(void)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputType , class OutputType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structThreadPool.html">ThreadPool</a>&lt; InputType, OutputType &gt;::LockInput           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lock the input buffer before calling the functions InputSize, InputAtIndex, and RemoveInputAtIndex It is only necessary to lock the input or output while the threads are running 
</div>
</div><p>
<a class="anchor" name="384ba5c62d60ac2e12e3f8aeea30d8bc"></a><!-- doxytag: member="ThreadPool::LockOutput" ref="384ba5c62d60ac2e12e3f8aeea30d8bc" args="(void)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputType , class OutputType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="structThreadPool.html">ThreadPool</a>&lt; InputType, OutputType &gt;::LockOutput           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Lock the output buffer before calling the functions OutputSize, OutputAtIndex, and RemoveOutputAtIndex It is only necessary to lock the input or output while the threads are running 
</div>
</div><p>
<a class="anchor" name="09fde0ca678340723840fae1dcda51a2"></a><!-- doxytag: member="ThreadPool::StartThreads" ref="09fde0ca678340723840fae1dcda51a2" args="(int numThreads, int stackSize, void *(*_perThreadInit)()=0, void(*_perThreadDeinit)(void *)=0)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class InputType , class OutputType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="structThreadPool.html">ThreadPool</a>&lt; InputType, OutputType &gt;::StartThreads           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>numThreads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>stackSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *(*)()&nbsp;</td>
          <td class="paramname"> <em>_perThreadInit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *)&nbsp;</td>
          <td class="paramname"> <em>_perThreadDeinit</em> = <code>0</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Start the specified number of threads. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numThreads</em>&nbsp;</td><td>The number of threads to start </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>stackSize</em>&nbsp;</td><td>0 for default (except on consoles). </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>_perThreadInit</em>&nbsp;</td><td>User callback to return data stored per thread. Pass 0 if not needed. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>_perThreadDeinit</em>&nbsp;</td><td>User callback to destroy data stored per thread, created by _perThreadInit. Pass 0 if not needed. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>True on success, false on failure. </dd></dl>

</div>
</div><p>
<hr>The documentation for this struct was generated from the following file:<ul>
<li>d:/temp/RakNet_PC/Source/ThreadPool.h</ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Feb 1 13:33:46 2012 for RakNet by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.7.1 </small></address>
</body>
</html>
