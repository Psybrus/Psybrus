<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>RakNet: DataStructures::Multilist&lt; _MultilistType, _DataType, _KeyType, _IndexType &gt; Class Template Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceDataStructures.html">DataStructures</a>::<a class="el" href="classDataStructures_1_1Multilist.html">Multilist</a>
  </div>
</div>
<div class="contents">
<h1>DataStructures::Multilist&lt; _MultilistType, _DataType, _KeyType, _IndexType &gt; Class Template Reference</h1><!-- doxytag: class="DataStructures::Multilist" -->The multilist, representing an abstract data type that generally holds lists.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;DS_Multilist.h&gt;</code>
<p>

<p>
<a href="classDataStructures_1_1Multilist-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataStructures_1_1Multilist.html#fe3f119b9f715a88fc6dd356689f7e72">Push</a> (const _DataType &amp;d, const char *file=__FILE__, unsigned int line=__LINE__)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="09e7c33fe9587c1902ed1551d720f7b7"></a><!-- doxytag: member="DataStructures::Multilist::Pop" ref="09e7c33fe9587c1902ed1551d720f7b7" args="(const char *file=__FILE__, unsigned int line=__LINE__)" -->
_DataType &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataStructures_1_1Multilist.html#09e7c33fe9587c1902ed1551d720f7b7">Pop</a> (const char *file=__FILE__, unsigned int line=__LINE__)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets or removes and gets an element from the list, according to the same rules as <a class="el" href="classDataStructures_1_1Multilist.html#fe3f119b9f715a88fc6dd356689f7e72">Push()</a>. Ordered list is LIFO for the purposes of Pop and Peek. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1596f547cb2b038726d2d733930e44be"></a><!-- doxytag: member="DataStructures::Multilist::PushOpposite" ref="1596f547cb2b038726d2d733930e44be" args="(const _DataType &amp;d, const char *file=__FILE__, unsigned int line=__LINE__)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataStructures_1_1Multilist.html#1596f547cb2b038726d2d733930e44be">PushOpposite</a> (const _DataType &amp;d, const char *file=__FILE__, unsigned int line=__LINE__)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as <a class="el" href="classDataStructures_1_1Multilist.html#fe3f119b9f715a88fc6dd356689f7e72">Push()</a>, except FIFO and LIFO are reversed. Ordered list still inserts in order. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5788e4bea29895d318226b5b943d5954"></a><!-- doxytag: member="DataStructures::Multilist::PopOpposite" ref="5788e4bea29895d318226b5b943d5954" args="(const char *file=__FILE__, unsigned int line=__LINE__)" -->
_DataType &amp;&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataStructures_1_1Multilist.html#5788e4bea29895d318226b5b943d5954">PopOpposite</a> (const char *file=__FILE__, unsigned int line=__LINE__)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as <a class="el" href="classDataStructures_1_1Multilist.html#09e7c33fe9587c1902ed1551d720f7b7" title="Gets or removes and gets an element from the list, according to the same rules as...">Pop()</a> and Peek(), except FIFO and LIFO are reversed. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="2192553f7ca8b678719cef4643d0d143"></a><!-- doxytag: member="DataStructures::Multilist::InsertAtIndex" ref="2192553f7ca8b678719cef4643d0d143" args="(const _DataType &amp;d, _IndexType index, const char *file=__FILE__, unsigned int line=__LINE__)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataStructures_1_1Multilist.html#2192553f7ca8b678719cef4643d0d143">InsertAtIndex</a> (const _DataType &amp;d, _IndexType index, const char *file=__FILE__, unsigned int line=__LINE__)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Stack,<a class="el" href="classDataStructures_1_1Queue.html" title="A queue implemented as an array with a read and write index.">Queue</a>: Inserts at index indicated, elements are shifted. Ordered list: Inserts, position is ignored. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataStructures_1_1Multilist.html#33dd81344fc1e3ddada972637cfe27c3">RemoveAtIndex</a> (_IndexType position, const char *file=__FILE__, unsigned int line=__LINE__)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Unordered list, removes at index indicated, swaps last element with that element. Otherwise, array is shifted left to overwrite removed element.  <a href="#33dd81344fc1e3ddada972637cfe27c3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="a3c83303215bacfc4510640efc062d39"></a><!-- doxytag: member="DataStructures::Multilist::RemoveAtKey" ref="a3c83303215bacfc4510640efc062d39" args="(_KeyType key, bool assertIfDoesNotExist, const char *file=__FILE__, unsigned int line=__LINE__)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataStructures_1_1Multilist.html#a3c83303215bacfc4510640efc062d39">RemoveAtKey</a> (_KeyType key, bool assertIfDoesNotExist, const char *file=__FILE__, unsigned int line=__LINE__)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Find the index of <em>key</em>, and remove at that index. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="84be6225dbac07350dee2ff8a8210e17"></a><!-- doxytag: member="DataStructures::Multilist::GetIndexOf" ref="84be6225dbac07350dee2ff8a8210e17" args="(_KeyType key) const " -->
_IndexType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataStructures_1_1Multilist.html#84be6225dbac07350dee2ff8a8210e17">GetIndexOf</a> (_KeyType key) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds the index of <em>key</em>. Return -1 if the key is not found. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f0e4d9aacbd1b22979a50dcd91522735"></a><!-- doxytag: member="DataStructures::Multilist::GetInsertionIndex" ref="f0e4d9aacbd1b22979a50dcd91522735" args="(_KeyType key) const " -->
_IndexType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataStructures_1_1Multilist.html#f0e4d9aacbd1b22979a50dcd91522735">GetInsertionIndex</a> (_KeyType key) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns where in the list we should insert the item, to preserve list order. Returns -1 if the item is already in the list. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="f718a952c67cb8e19e9863f087101340"></a><!-- doxytag: member="DataStructures::Multilist::GetPtr" ref="f718a952c67cb8e19e9863f087101340" args="(_KeyType key) const " -->
_DataType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataStructures_1_1Multilist.html#f718a952c67cb8e19e9863f087101340">GetPtr</a> (_KeyType key) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds the index of <em>key</em>. Return 0 if the key is not found. Useful if _DataType is always non-zero pointers. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4e49b2800f3cfebdc4fa22e3ded43689"></a><!-- doxytag: member="DataStructures::Multilist::ForEach" ref="4e49b2800f3cfebdc4fa22e3ded43689" args="(void(*func)(_DataType &amp;item, const char *file, unsigned int line), const char *file, unsigned int line)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataStructures_1_1Multilist.html#4e49b2800f3cfebdc4fa22e3ded43689">ForEach</a> (void(*func)(_DataType &amp;item, const char *file, unsigned int line), const char *file, unsigned int line)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Iterate over the list, calling the function pointer on each element. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8d58006a5444efa6487d21faa8310bfe"></a><!-- doxytag: member="DataStructures::Multilist::IsEmpty" ref="8d58006a5444efa6487d21faa8310bfe" args="(void) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataStructures_1_1Multilist.html#8d58006a5444efa6487d21faa8310bfe">IsEmpty</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns if the list is empty. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="374ed61cd2124ffd01e0bab732f89e61"></a><!-- doxytag: member="DataStructures::Multilist::GetSize" ref="374ed61cd2124ffd01e0bab732f89e61" args="(void) const " -->
_IndexType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataStructures_1_1Multilist.html#374ed61cd2124ffd01e0bab732f89e61">GetSize</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of elements used in the list. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="837e5a1793a397c26580de337c4a4207"></a><!-- doxytag: member="DataStructures::Multilist::Clear" ref="837e5a1793a397c26580de337c4a4207" args="(bool deallocateSmallBlocks=true, const char *file=__FILE__, unsigned int line=__LINE__)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataStructures_1_1Multilist.html#837e5a1793a397c26580de337c4a4207">Clear</a> (bool deallocateSmallBlocks=true, const char *file=__FILE__, unsigned int line=__LINE__)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Empties the list. The list is not deallocated if it is small, unless <em>deallocateSmallBlocks</em> is true. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataStructures_1_1Multilist.html#8ea6e9cc49fa6c858114db3540264d7b">ClearPointers</a> (bool deallocateSmallBlocks=true, const char *file=__FILE__, unsigned int line=__LINE__)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Empties the list, first calling RakNet::OP_Delete on all items.  <a href="#8ea6e9cc49fa6c858114db3540264d7b"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="4d96ab0baeb2c566f3f5e0c20be880ed"></a><!-- doxytag: member="DataStructures::Multilist::ClearPointer" ref="4d96ab0baeb2c566f3f5e0c20be880ed" args="(_KeyType key, const char *file=__FILE__, unsigned int line=__LINE__)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataStructures_1_1Multilist.html#4d96ab0baeb2c566f3f5e0c20be880ed">ClearPointer</a> (_KeyType key, const char *file=__FILE__, unsigned int line=__LINE__)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Empty one item from the list, first calling RakNet::OP_Delete on that item. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1b8cc2c4515e66ace8a1efe3d045eaf0"></a><!-- doxytag: member="DataStructures::Multilist::ReverseList" ref="1b8cc2c4515e66ace8a1efe3d045eaf0" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataStructures_1_1Multilist.html#1b8cc2c4515e66ace8a1efe3d045eaf0">ReverseList</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reverses the elements in the list, and flips the sort order returned by <a class="el" href="classDataStructures_1_1Multilist.html#800048ec6f280da5e7a161a22a43b87b" title="Returns true if ascending.">GetSortOrder()</a> if <a class="el" href="classDataStructures_1_1Multilist.html#acbab3fd63f299185141b0c4a62e9ef5" title="Returns true if the list is currently believed to be in a sorted state.">IsSorted()</a> returns true at the time the function is called. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="15148dd58d303f1f6d72ecf5d1663aea"></a><!-- doxytag: member="DataStructures::Multilist::Reallocate" ref="15148dd58d303f1f6d72ecf5d1663aea" args="(_IndexType size, const char *file=__FILE__, unsigned int line=__LINE__)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataStructures_1_1Multilist.html#15148dd58d303f1f6d72ecf5d1663aea">Reallocate</a> (_IndexType size, const char *file=__FILE__, unsigned int line=__LINE__)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reallocates the list to a larger size. If <em>size</em> is smaller than the value returned by <a class="el" href="classDataStructures_1_1Multilist.html#374ed61cd2124ffd01e0bab732f89e61" title="Returns the number of elements used in the list.">GetSize()</a>, the call does nothing. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataStructures_1_1Multilist.html#f7c98eb3dd4a13343695b810c5f6d2c4">Sort</a> (bool force)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sorts the list unless it is an ordered list, in which it does nothing as the list is assumed to already be sorted.  <a href="#f7c98eb3dd4a13343695b810c5f6d2c4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataStructures_1_1Multilist.html#3d07bd2615004b6903a6ae8387238fa9">TagSorted</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the list to be remembered as sorted.  <a href="#3d07bd2615004b6903a6ae8387238fa9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataStructures_1_1Multilist.html#219bfa477ce7722e32462e97c6876634">SetSortOrder</a> (bool ascending)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Defaults to ascending.  <a href="#219bfa477ce7722e32462e97c6876634"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="800048ec6f280da5e7a161a22a43b87b"></a><!-- doxytag: member="DataStructures::Multilist::GetSortOrder" ref="800048ec6f280da5e7a161a22a43b87b" args="(void) const " -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataStructures_1_1Multilist.html#800048ec6f280da5e7a161a22a43b87b">GetSortOrder</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if ascending. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataStructures_1_1Multilist.html#acbab3fd63f299185141b0c4a62e9ef5">IsSorted</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns true if the list is currently believed to be in a sorted state.  <a href="#acbab3fd63f299185141b0c4a62e9ef5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b3a1eb26b60fc9742c3d9d842b1807cc"></a><!-- doxytag: member="DataStructures::Multilist::GetMultilistType" ref="b3a1eb26b60fc9742c3d9d842b1807cc" args="(void) const " -->
<a class="el" href="DS__Multilist_8h.html#8387ff66ed3a8c8a6c0528ddb5650a5b">MultilistType</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataStructures_1_1Multilist.html#b3a1eb26b60fc9742c3d9d842b1807cc">GetMultilistType</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns what type of list this is. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataStructures_1_1Multilist.html#054b07faf5e383569219911f18615a39">SetMultilistType</a> (<a class="el" href="DS__Multilist_8h.html#8387ff66ed3a8c8a6c0528ddb5650a5b">MultilistType</a> newType)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Changes what type of list this is.  <a href="#054b07faf5e383569219911f18615a39"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="5958435ddcd5ac367ab0406fc797c00a"></a><!-- doxytag: member="DataStructures::Multilist::FindIntersection" ref="5958435ddcd5ac367ab0406fc797c00a" args="(Multilist &amp;source1, Multilist &amp;source2, Multilist &amp;intersection, Multilist &amp;uniqueToSource1, Multilist &amp;uniqueToSource2)" -->
static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataStructures_1_1Multilist.html#5958435ddcd5ac367ab0406fc797c00a">FindIntersection</a> (<a class="el" href="classDataStructures_1_1Multilist.html">Multilist</a> &amp;source1, <a class="el" href="classDataStructures_1_1Multilist.html">Multilist</a> &amp;source2, <a class="el" href="classDataStructures_1_1Multilist.html">Multilist</a> &amp;intersection, <a class="el" href="classDataStructures_1_1Multilist.html">Multilist</a> &amp;uniqueToSource1, <a class="el" href="classDataStructures_1_1Multilist.html">Multilist</a> &amp;uniqueToSource2)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the intersection of two lists. Intersection is items common to both lists. <br></td></tr>
<tr><td colspan="2"><br><h2>Protected Attributes</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="cf634946f450bd5884fb3bcae33fd689"></a><!-- doxytag: member="DataStructures::Multilist::data" ref="cf634946f450bd5884fb3bcae33fd689" args="" -->
_DataType *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataStructures_1_1Multilist.html#cf634946f450bd5884fb3bcae33fd689">data</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An array of user values. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b6561cddc98dd8ab653f56a4203a8ded"></a><!-- doxytag: member="DataStructures::Multilist::dataSize" ref="b6561cddc98dd8ab653f56a4203a8ded" args="" -->
_IndexType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataStructures_1_1Multilist.html#b6561cddc98dd8ab653f56a4203a8ded">dataSize</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Number of elements in the list. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="6040ead73a8eed4667d92e7b66d13db9"></a><!-- doxytag: member="DataStructures::Multilist::allocationSize" ref="6040ead73a8eed4667d92e7b66d13db9" args="" -->
_IndexType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataStructures_1_1Multilist.html#6040ead73a8eed4667d92e7b66d13db9">allocationSize</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Size of <em>array</em>. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9278b3e4d57e3dedd3f613c78ead4461"></a><!-- doxytag: member="DataStructures::Multilist::queueHead" ref="9278b3e4d57e3dedd3f613c78ead4461" args="" -->
_IndexType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataStructures_1_1Multilist.html#9278b3e4d57e3dedd3f613c78ead4461">queueHead</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Array index for the head of the queue. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="300a64c3629be9ece749f944c5d05525"></a><!-- doxytag: member="DataStructures::Multilist::queueTail" ref="300a64c3629be9ece749f944c5d05525" args="" -->
_IndexType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataStructures_1_1Multilist.html#300a64c3629be9ece749f944c5d05525">queueTail</a></td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Array index for the tail of the queue. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">_IndexType&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataStructures_1_1Multilist.html#aa5f425e786988300c1cc1c782173b4c">preallocationSize</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;const MultilistType _MultilistType, class _DataType, class _KeyType = _DataType, class _IndexType = DefaultIndexType&gt;<br>
 class DataStructures::Multilist&lt; _MultilistType, _DataType, _KeyType, _IndexType &gt;</h3>

The multilist, representing an abstract data type that generally holds lists. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>_MultilistType</em>&nbsp;</td><td>What type of list this is, </td></tr>
  </table>
</dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="DS__Multilist_8h.html#8387ff66ed3a8c8a6c0528ddb5650a5b" title="What algorithm to use to store the data for the Multilist.">MultilistType</a> </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>_DataType</em>&nbsp;</td><td>What type of data this list holds. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>_KeyType</em>&nbsp;</td><td>If a function takes a key to sort on, what type of key this is. The comparison operator between _DataType and _KeyType must be defined </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>_IndexType</em>&nbsp;</td><td>What variable type to use for indices </td></tr>
  </table>
</dl>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="8ea6e9cc49fa6c858114db3540264d7b"></a><!-- doxytag: member="DataStructures::Multilist::ClearPointers" ref="8ea6e9cc49fa6c858114db3540264d7b" args="(bool deallocateSmallBlocks=true, const char *file=__FILE__, unsigned int line=__LINE__)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const MultilistType _MultilistType, class _DataType , class _KeyType , class _IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataStructures_1_1Multilist.html">DataStructures::Multilist</a>&lt; _MultilistType, _DataType, _KeyType, _IndexType &gt;::ClearPointers           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>deallocateSmallBlocks</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file</em> = <code>__FILE__</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>line</em> = <code>__LINE__</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Empties the list, first calling RakNet::OP_Delete on all items. 
<p>
The list is not deallocated if it is small, unless <em>deallocateSmallBlocks</em> is true 
</div>
</div><p>
<a class="anchor" name="acbab3fd63f299185141b0c4a62e9ef5"></a><!-- doxytag: member="DataStructures::Multilist::IsSorted" ref="acbab3fd63f299185141b0c4a62e9ef5" args="(void) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const MultilistType _MultilistType, class _DataType , class _KeyType , class _IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classDataStructures_1_1Multilist.html">DataStructures::Multilist</a>&lt; _MultilistType, _DataType, _KeyType, _IndexType &gt;::IsSorted           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the list is currently believed to be in a sorted state. 
<p>
Doesn't actually check for sortedness, just if <a class="el" href="classDataStructures_1_1Multilist.html#f7c98eb3dd4a13343695b810c5f6d2c4" title="Sorts the list unless it is an ordered list, in which it does nothing as the list...">Sort()</a> was recently called, or MultilistType is ML_ORDERED_LIST 
</div>
</div><p>
<a class="anchor" name="fe3f119b9f715a88fc6dd356689f7e72"></a><!-- doxytag: member="DataStructures::Multilist::Push" ref="fe3f119b9f715a88fc6dd356689f7e72" args="(const _DataType &amp;d, const char *file=__FILE__, unsigned int line=__LINE__)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const MultilistType _MultilistType, class _DataType , class _KeyType , class _IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataStructures_1_1Multilist.html">DataStructures::Multilist</a>&lt; _MultilistType, _DataType, _KeyType, _IndexType &gt;::Push           </td>
          <td>(</td>
          <td class="paramtype">const _DataType &amp;&nbsp;</td>
          <td class="paramname"> <em>d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file</em> = <code>__FILE__</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>line</em> = <code>__LINE__</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unordered list, stack is LIFO QUEUE is FIFO Ordered list is inserted in order 
</div>
</div><p>
<a class="anchor" name="33dd81344fc1e3ddada972637cfe27c3"></a><!-- doxytag: member="DataStructures::Multilist::RemoveAtIndex" ref="33dd81344fc1e3ddada972637cfe27c3" args="(_IndexType position, const char *file=__FILE__, unsigned int line=__LINE__)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const MultilistType _MultilistType, class _DataType , class _KeyType , class _IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataStructures_1_1Multilist.html">DataStructures::Multilist</a>&lt; _MultilistType, _DataType, _KeyType, _IndexType &gt;::RemoveAtIndex           </td>
          <td>(</td>
          <td class="paramtype">_IndexType&nbsp;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>file</em> = <code>__FILE__</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&nbsp;</td>
          <td class="paramname"> <em>line</em> = <code>__LINE__</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unordered list, removes at index indicated, swaps last element with that element. Otherwise, array is shifted left to overwrite removed element. 
<p>
Index[0] returns the same as <a class="el" href="classDataStructures_1_1Multilist.html#09e7c33fe9587c1902ed1551d720f7b7" title="Gets or removes and gets an element from the list, according to the same rules as...">Pop()</a> for a queue. Same as <a class="el" href="classDataStructures_1_1Multilist.html#5788e4bea29895d318226b5b943d5954" title="Same as Pop() and Peek(), except FIFO and LIFO are reversed.">PopOpposite()</a> for the list and ordered list 
</div>
</div><p>
<a class="anchor" name="054b07faf5e383569219911f18615a39"></a><!-- doxytag: member="DataStructures::Multilist::SetMultilistType" ref="054b07faf5e383569219911f18615a39" args="(MultilistType newType)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const MultilistType _MultilistType, class _DataType , class _KeyType , class _IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataStructures_1_1Multilist.html">DataStructures::Multilist</a>&lt; _MultilistType, _DataType, _KeyType, _IndexType &gt;::SetMultilistType           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="DS__Multilist_8h.html#8387ff66ed3a8c8a6c0528ddb5650a5b">MultilistType</a>&nbsp;</td>
          <td class="paramname"> <em>newType</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Changes what type of list this is. 
<p>
<dl class="pre" compact><dt><b>Precondition:</b></dt><dd>Template must be defined with ML_VARIABLE_DURING_RUNTIME for this to do anything </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>mlType</em>&nbsp;</td><td>Any value of the enum MultilistType, except ML_VARIABLE_DURING_RUNTIME </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="219bfa477ce7722e32462e97c6876634"></a><!-- doxytag: member="DataStructures::Multilist::SetSortOrder" ref="219bfa477ce7722e32462e97c6876634" args="(bool ascending)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const MultilistType _MultilistType, class _DataType , class _KeyType , class _IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataStructures_1_1Multilist.html">DataStructures::Multilist</a>&lt; _MultilistType, _DataType, _KeyType, _IndexType &gt;::SetSortOrder           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>ascending</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Defaults to ascending. 
<p>
Used by <a class="el" href="classDataStructures_1_1Multilist.html#f7c98eb3dd4a13343695b810c5f6d2c4" title="Sorts the list unless it is an ordered list, in which it does nothing as the list...">Sort()</a>, and by ML_ORDERED_LIST 
</div>
</div><p>
<a class="anchor" name="f7c98eb3dd4a13343695b810c5f6d2c4"></a><!-- doxytag: member="DataStructures::Multilist::Sort" ref="f7c98eb3dd4a13343695b810c5f6d2c4" args="(bool force)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const MultilistType _MultilistType, class _DataType , class _KeyType , class _IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataStructures_1_1Multilist.html">DataStructures::Multilist</a>&lt; _MultilistType, _DataType, _KeyType, _IndexType &gt;::Sort           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>force</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sorts the list unless it is an ordered list, in which it does nothing as the list is assumed to already be sorted. 
<p>
However, if <em>force</em> is true, it will also resort the ordered list, useful if the comparison operator between _KeyType and _DataType would now return different results Once the list is sorted, further operations to lookup by key will be log2(n) until the list is modified 
</div>
</div><p>
<a class="anchor" name="3d07bd2615004b6903a6ae8387238fa9"></a><!-- doxytag: member="DataStructures::Multilist::TagSorted" ref="3d07bd2615004b6903a6ae8387238fa9" args="(void)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const MultilistType _MultilistType, class _DataType , class _KeyType , class _IndexType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataStructures_1_1Multilist.html">DataStructures::Multilist</a>&lt; _MultilistType, _DataType, _KeyType, _IndexType &gt;::TagSorted           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the list to be remembered as sorted. 
<p>
Optimization if the source is sorted already 
</div>
</div><p>
<hr><h2>Member Data Documentation</h2>
<a class="anchor" name="aa5f425e786988300c1cc1c782173b4c"></a><!-- doxytag: member="DataStructures::Multilist::preallocationSize" ref="aa5f425e786988300c1cc1c782173b4c" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;const MultilistType _MultilistType, class _DataType , class _KeyType  = _DataType, class _IndexType  = DefaultIndexType&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">_IndexType <a class="el" href="classDataStructures_1_1Multilist.html">DataStructures::Multilist</a>&lt; _MultilistType, _DataType, _KeyType, _IndexType &gt;::<a class="el" href="classDataStructures_1_1Multilist.html#aa5f425e786988300c1cc1c782173b4c">preallocationSize</a><code> [protected]</code>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
How many bytes the user chose to preallocate Won't automatically deallocate below this 
</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>d:/temp/RakNet_PC/Source/<a class="el" href="DS__Multilist_8h.html">DS_Multilist.h</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Feb 1 13:33:46 2012 for RakNet by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.7.1 </small></address>
</body>
</html>
