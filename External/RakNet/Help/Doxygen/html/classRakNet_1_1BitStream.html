<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>RakNet: RakNet::BitStream Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="tabs">
    <ul>
      <li><a href="annotated.html"><span>Class&nbsp;List</span></a></li>
      <li><a href="classes.html"><span>Class&nbsp;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&nbsp;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&nbsp;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="namespaceRakNet.html">RakNet</a>::<a class="el" href="classRakNet_1_1BitStream.html">BitStream</a>
  </div>
</div>
<div class="contents">
<h1>RakNet::BitStream Class Reference</h1><!-- doxytag: class="RakNet::BitStream" --><code>#include &lt;BitStream.h&gt;</code>
<p>

<p>
<a href="classRakNet_1_1BitStream-members.html">List of all members.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1aeb4088ac7a611c9eebc629df86890c"></a><!-- doxytag: member="RakNet::BitStream::BitStream" ref="1aeb4088ac7a611c9eebc629df86890c" args="()" -->
&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#1aeb4088ac7a611c9eebc629df86890c">BitStream</a> ()</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Default Constructor. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#47b1c7ce200c4815bd2a42d454244bb4">BitStream</a> (const unsigned int initialBytesToAllocate)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Create the bitstream, with some number of bytes to immediately allocate.  <a href="#47b1c7ce200c4815bd2a42d454244bb4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#04a200eaf5b379cad2e30d5de15a2c9a">BitStream</a> (unsigned char *_data, const unsigned int lengthInBytes, bool _copyData)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Initialize the <a class="el" href="classRakNet_1_1BitStream.html">BitStream</a>, immediately setting the data it contains to a predefined pointer.  <a href="#04a200eaf5b379cad2e30d5de15a2c9a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="60690472e9540e6c3f4b69961e19440f"></a><!-- doxytag: member="RakNet::BitStream::Reset" ref="60690472e9540e6c3f4b69961e19440f" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#60690472e9540e6c3f4b69961e19440f">Reset</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Resets the bitstream for reuse. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class templateType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#d2e1037f884caf1b8bc965655a4ee1f6">Serialize</a> (bool writeToBitstream, templateType &amp;inOutTemplateVar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bidirectional serialize/deserialize any integral type to/from a bitstream.  <a href="#d2e1037f884caf1b8bc965655a4ee1f6"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class templateType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#27ecb5bf560591d9dc99d329be2a59f0">SerializeDelta</a> (bool writeToBitstream, templateType &amp;inOutCurrentValue, const templateType &amp;lastValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bidirectional serialize/deserialize any integral type to/from a bitstream.  <a href="#27ecb5bf560591d9dc99d329be2a59f0"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class templateType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#776115b23e4e15af05c46003d2d2d2b4">SerializeDelta</a> (bool writeToBitstream, templateType &amp;inOutCurrentValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bidirectional version of SerializeDelta when you don't know what the last value is, or there is no last value.  <a href="#776115b23e4e15af05c46003d2d2d2b4"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class templateType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#f961981b0774a90109a765b08eecd019">SerializeCompressed</a> (bool writeToBitstream, templateType &amp;inOutTemplateVar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bidirectional serialize/deserialize any integral type to/from a bitstream.  <a href="#f961981b0774a90109a765b08eecd019"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class templateType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#80d6eb64fd0a336b2572a2cb3c3dfad1">SerializeCompressedDelta</a> (bool writeToBitstream, templateType &amp;inOutCurrentValue, const templateType &amp;lastValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bidirectional serialize/deserialize any integral type to/from a bitstream.  <a href="#80d6eb64fd0a336b2572a2cb3c3dfad1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class templateType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#cbd582bb54666cd9e6e58f708df9ca65">SerializeCompressedDelta</a> (bool writeToBitstream, templateType &amp;inOutTemplateVar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save as SerializeCompressedDelta(templateType &amp;currentValue, const templateType &amp;lastValue) when we have an unknown second parameter.  <a href="#cbd582bb54666cd9e6e58f708df9ca65"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#d2e3ec310191a69b9bba227a72e65537">Serialize</a> (bool writeToBitstream, char *inOutByteArray, const unsigned int numberOfBytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bidirectional serialize/deserialize an array or casted stream or raw data. This does NOT do endian swapping.  <a href="#d2e3ec310191a69b9bba227a72e65537"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#1aebab1c543acd21742f380c95255365">SerializeFloat16</a> (bool writeToBitstream, float &amp;inOutFloat, float floatMin, float floatMax)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Serialize a float into 2 bytes, spanning the range between <em>floatMin</em> and <em>floatMax</em>.  <a href="#1aebab1c543acd21742f380c95255365"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class serializationType , class sourceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#180c7177b56b1afaf58c671e2ac9cafc">SerializeCasted</a> (bool writeToBitstream, sourceType &amp;value)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class templateType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#8718889282a4aee473ef48efe4934fd5">SerializeBitsFromIntegerRange</a> (bool writeToBitstream, templateType &amp;value, const templateType minimum, const templateType maximum, bool allowOutsideRange=false)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class templateType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#fc3e191bc13f1e9a768fa5073c74a4eb">SerializeBitsFromIntegerRange</a> (bool writeToBitstream, templateType &amp;value, const templateType minimum, const templateType maximum, const int requiredBits, bool allowOutsideRange=false)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class templateType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#d4fec447540af6e5959c0335bd2b0f18">SerializeNormVector</a> (bool writeToBitstream, templateType &amp;x, templateType &amp;y, templateType &amp;z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bidirectional serialize/deserialize a normalized 3D vector, using (at most) 4 bytes + 3 bits instead of 12-24 bytes.  <a href="#d4fec447540af6e5959c0335bd2b0f18"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class templateType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#62e28b643291d050ca0984b432753e8f">SerializeVector</a> (bool writeToBitstream, templateType &amp;x, templateType &amp;y, templateType &amp;z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bidirectional serialize/deserialize a vector, using 10 bytes instead of 12.  <a href="#62e28b643291d050ca0984b432753e8f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class templateType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#885aa48b92f84f386d2e22902c0b20ca">SerializeNormQuat</a> (bool writeToBitstream, templateType &amp;w, templateType &amp;x, templateType &amp;y, templateType &amp;z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bidirectional serialize/deserialize a normalized quaternion in 6 bytes + 4 bits instead of 16 bytes. Slightly lossy.  <a href="#885aa48b92f84f386d2e22902c0b20ca"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class templateType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#c46a69cb205c73377be00b31fa78699e">SerializeOrthMatrix</a> (bool writeToBitstream, templateType &amp;m00, templateType &amp;m01, templateType &amp;m02, templateType &amp;m10, templateType &amp;m11, templateType &amp;m12, templateType &amp;m20, templateType &amp;m21, templateType &amp;m22)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bidirectional serialize/deserialize an orthogonal matrix by creating a quaternion, and writing 3 components of the quaternion in 2 bytes each.  <a href="#c46a69cb205c73377be00b31fa78699e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#25c0f31d16b211a2aa7cdb3ec594cbf9">SerializeBits</a> (bool writeToBitstream, unsigned char *inOutByteArray, const BitSize_t numberOfBitsToSerialize, const bool rightAlignedBits=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Bidirectional serialize/deserialize numberToSerialize bits to/from the input.  <a href="#25c0f31d16b211a2aa7cdb3ec594cbf9"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class templateType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#260675ffb5cb824cbed3465b0319383c">Write</a> (const templateType &amp;inTemplateVar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write any integral type to a bitstream.  <a href="#260675ffb5cb824cbed3465b0319383c"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class templateType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#9e537be47615fc625f47f7f99f3955fb">WritePtr</a> (templateType *inTemplateVar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write the dereferenced pointer to any integral type to a bitstream.  <a href="#9e537be47615fc625f47f7f99f3955fb"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class templateType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#9b68a7467d37b6f4a46e29de8dec6fec">WriteDelta</a> (const templateType &amp;currentValue, const templateType &amp;lastValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write any integral type to a bitstream.  <a href="#9b68a7467d37b6f4a46e29de8dec6fec"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class templateType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#ab257336c9c88be2b3cdbfcfa1d58959">WriteDelta</a> (const templateType &amp;currentValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">WriteDelta when you don't know what the last value is, or there is no last value.  <a href="#ab257336c9c88be2b3cdbfcfa1d58959"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class templateType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#f2a9f9515ed4783e832e5822942003a8">WriteCompressed</a> (const templateType &amp;inTemplateVar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write any integral type to a bitstream.  <a href="#f2a9f9515ed4783e832e5822942003a8"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class templateType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#6de88ae0698472b2fdd968c95bc478fb">WriteCompressedDelta</a> (const templateType &amp;currentValue, const templateType &amp;lastValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write any integral type to a bitstream.  <a href="#6de88ae0698472b2fdd968c95bc478fb"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class templateType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#202c4a2557df531aca0cfabcbe956dfe">WriteCompressedDelta</a> (const templateType &amp;currentValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save as <a class="el" href="classRakNet_1_1BitStream.html#6de88ae0698472b2fdd968c95bc478fb" title="Write any integral type to a bitstream.">WriteCompressedDelta(const templateType &amp;currentValue, const templateType &amp;lastValue)</a> when we have an unknown second parameter.  <a href="#202c4a2557df531aca0cfabcbe956dfe"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class templateType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#45c9d2484823bb62430ded4d7eeda201">Read</a> (templateType &amp;outTemplateVar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read any integral type from a bitstream.  <a href="#45c9d2484823bb62430ded4d7eeda201"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class templateType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#e1fa85a18abdabca0818e3e8a6e9bd1b">ReadDelta</a> (templateType &amp;outTemplateVar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read any integral type from a bitstream.  <a href="#e1fa85a18abdabca0818e3e8a6e9bd1b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class templateType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#c8f5c1748ce9fdf797cc9e8e8bdd082f">ReadCompressed</a> (templateType &amp;outTemplateVar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read any integral type from a bitstream.  <a href="#c8f5c1748ce9fdf797cc9e8e8bdd082f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class templateType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#ac829439f72872ee3962509e19440b11">ReadCompressedDelta</a> (templateType &amp;outTemplateVar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read any integral type from a bitstream.  <a href="#ac829439f72872ee3962509e19440b11"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#025f73d57a5ebe8fb6393eca5f3616df">Read</a> (<a class="el" href="classRakNet_1_1BitStream.html">BitStream</a> *bitStream, BitSize_t numberOfBits)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read one bitstream to another.  <a href="#025f73d57a5ebe8fb6393eca5f3616df"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#0c6e2624a5960f9ac40d4072a6e607e5">Write</a> (const char *inputByteArray, const unsigned int numberOfBytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write an array or casted stream or raw data. This does NOT do endian swapping.  <a href="#0c6e2624a5960f9ac40d4072a6e607e5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#26624b5669df1c38f6dd6dabf4c1b769">Write</a> (<a class="el" href="classRakNet_1_1BitStream.html">BitStream</a> *bitStream, BitSize_t numberOfBits)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write one bitstream to another.  <a href="#26624b5669df1c38f6dd6dabf4c1b769"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#8b37ff9ba34ce6f98c8521710ba51366">WriteFloat16</a> (float x, float floatMin, float floatMax)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a float into 2 bytes, spanning the range between <em>floatMin</em> and <em>floatMax</em>.  <a href="#8b37ff9ba34ce6f98c8521710ba51366"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class serializationType , class sourceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#9f99f5796c7124daebc5d71776dd641d">WriteCasted</a> (const sourceType &amp;value)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class templateType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#c28f6c4fb26bedc0858ed478961c2dc1">WriteBitsFromIntegerRange</a> (const templateType value, const templateType minimum, const templateType maximum, bool allowOutsideRange=false)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class templateType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#d64fbada82c7df3f8a191b13a27d0027">WriteBitsFromIntegerRange</a> (const templateType value, const templateType minimum, const templateType maximum, const int requiredBits, bool allowOutsideRange=false)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class templateType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#95cfc5e892e308e6cda4738d6001ee61">WriteNormVector</a> (templateType x, templateType y, templateType z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a normalized 3D vector, using (at most) 4 bytes + 3 bits instead of 12-24 bytes.  <a href="#95cfc5e892e308e6cda4738d6001ee61"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class templateType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#92da13ea0b4bdf7676a8df2e2d0c68b7">WriteVector</a> (templateType x, templateType y, templateType z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a vector, using 10 bytes instead of 12.  <a href="#92da13ea0b4bdf7676a8df2e2d0c68b7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class templateType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#32d45047ed2c0904d4a4ce389c0cef97">WriteNormQuat</a> (templateType w, templateType x, templateType y, templateType z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a normalized quaternion in 6 bytes + 4 bits instead of 16 bytes. Slightly lossy.  <a href="#32d45047ed2c0904d4a4ce389c0cef97"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class templateType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#73c6f4399d99c74d379d0f12448bf7e3">WriteOrthMatrix</a> (templateType m00, templateType m01, templateType m02, templateType m10, templateType m11, templateType m12, templateType m20, templateType m21, templateType m22)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write an orthogonal matrix by creating a quaternion, and writing 3 components of the quaternion in 2 bytes each.  <a href="#73c6f4399d99c74d379d0f12448bf7e3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#25b53ddc6f6bc9a1e0c01cb677a3c6d1">Read</a> (char *output, const unsigned int numberOfBytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read an array or casted stream of byte.  <a href="#25b53ddc6f6bc9a1e0c01cb677a3c6d1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#f8275d390e2114d55449bb4ae2d01d62">ReadFloat16</a> (float &amp;outFloat, float floatMin, float floatMax)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a float into 2 bytes, spanning the range between <em>floatMin</em> and <em>floatMax</em>.  <a href="#f8275d390e2114d55449bb4ae2d01d62"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class serializationType , class sourceType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#fd466ad5445d355be0c6c9435eb602bd">ReadCasted</a> (sourceType &amp;value)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class templateType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#ac098d281b3d2f2eb193b99d7bc50956">ReadBitsFromIntegerRange</a> (templateType &amp;value, const templateType minimum, const templateType maximum, bool allowOutsideRange=false)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class templateType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#092f9780c4fa69b93e1ea3d89fb4d322">ReadBitsFromIntegerRange</a> (templateType &amp;value, const templateType minimum, const templateType maximum, const int requiredBits, bool allowOutsideRange=false)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class templateType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#3fe2307474325b610e2571d741c3ff5b">ReadNormVector</a> (templateType &amp;x, templateType &amp;y, templateType &amp;z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a normalized 3D vector, using (at most) 4 bytes + 3 bits instead of 12-24 bytes.  <a href="#3fe2307474325b610e2571d741c3ff5b"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class templateType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#5c22e455ff1ca1532faf709c2266815f">ReadVector</a> (templateType &amp;x, templateType &amp;y, templateType &amp;z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read 3 floats or doubles, using 10 bytes, where those float or doubles comprise a vector.  <a href="#5c22e455ff1ca1532faf709c2266815f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class templateType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#492d3b89ce89aafa804f99aa6e432be1">ReadNormQuat</a> (templateType &amp;w, templateType &amp;x, templateType &amp;y, templateType &amp;z)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a normalized quaternion in 6 bytes + 4 bits instead of 16 bytes.  <a href="#492d3b89ce89aafa804f99aa6e432be1"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;class templateType &gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#e6e4c9a69605709d5a449425ecad37fa">ReadOrthMatrix</a> (templateType &amp;m00, templateType &amp;m01, templateType &amp;m02, templateType &amp;m10, templateType &amp;m11, templateType &amp;m12, templateType &amp;m20, templateType &amp;m21, templateType &amp;m22)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read an orthogonal matrix from a quaternion, reading 3 components of the quaternion in 2 bytes each and extrapolatig the 4th.  <a href="#e6e4c9a69605709d5a449425ecad37fa"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="aa64a4efffbfc9f5e527061bb82126b8"></a><!-- doxytag: member="RakNet::BitStream::ResetReadPointer" ref="aa64a4efffbfc9f5e527061bb82126b8" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#aa64a4efffbfc9f5e527061bb82126b8">ResetReadPointer</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the read pointer back to the beginning of your data. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="9254b23b2873496aab84d2637d7488ee"></a><!-- doxytag: member="RakNet::BitStream::ResetWritePointer" ref="9254b23b2873496aab84d2637d7488ee" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#9254b23b2873496aab84d2637d7488ee">ResetWritePointer</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the write pointer back to the beginning of your data. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8492d958d2527a14813cc1a22a71b83a"></a><!-- doxytag: member="RakNet::BitStream::AssertStreamEmpty" ref="8492d958d2527a14813cc1a22a71b83a" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#8492d958d2527a14813cc1a22a71b83a">AssertStreamEmpty</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">This is good to call when you are done with the stream to make sure you didn't leave any data left over void. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="74cf3e238c0925fdbeb7b792a2f79626"></a><!-- doxytag: member="RakNet::BitStream::PrintBits" ref="74cf3e238c0925fdbeb7b792a2f79626" args="(char *out) const " -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#74cf3e238c0925fdbeb7b792a2f79626">PrintBits</a> (char *out) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">RAKNET_DEBUG_PRINTF the bits in the stream. Great for debugging. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#1952b3b3007b120fdd143f87311a98a2">IgnoreBits</a> (const BitSize_t numberOfBits)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ignore data we don't intend to read.  <a href="#1952b3b3007b120fdd143f87311a98a2"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#26310ba75436c24a1272e65da6a90a1e">IgnoreBytes</a> (const unsigned int numberOfBytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Ignore data we don't intend to read.  <a href="#26310ba75436c24a1272e65da6a90a1e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a56ebc6a1381369ddc2a6d7821512d7e">SetWriteOffset</a> (const BitSize_t offset)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move the write pointer to a position on the array.  <a href="#a56ebc6a1381369ddc2a6d7821512d7e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="403d4d6ada2fd98bc78943124fc1276a"></a><!-- doxytag: member="RakNet::BitStream::GetNumberOfBitsUsed" ref="403d4d6ada2fd98bc78943124fc1276a" args="(void) const " -->
BitSize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#403d4d6ada2fd98bc78943124fc1276a">GetNumberOfBitsUsed</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the length in bits of the stream. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="98478b4da2e29d5923c0ae80bda76f97"></a><!-- doxytag: member="RakNet::BitStream::GetNumberOfBytesUsed" ref="98478b4da2e29d5923c0ae80bda76f97" args="(void) const " -->
BitSize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#98478b4da2e29d5923c0ae80bda76f97">GetNumberOfBytesUsed</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the length in bytes of the stream. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="b4fa9312c1d16efd18059e38569c4bb1"></a><!-- doxytag: member="RakNet::BitStream::GetReadOffset" ref="b4fa9312c1d16efd18059e38569c4bb1" args="(void) const " -->
BitSize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#b4fa9312c1d16efd18059e38569c4bb1">GetReadOffset</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of bits into the stream that we have read. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d7a63454d1e1f26c659c3ebb65bd76ba"></a><!-- doxytag: member="RakNet::BitStream::SetReadOffset" ref="d7a63454d1e1f26c659c3ebb65bd76ba" args="(const BitSize_t newReadOffset)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#d7a63454d1e1f26c659c3ebb65bd76ba">SetReadOffset</a> (const BitSize_t newReadOffset)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Sets the read bit index. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="7a853a0e55000f302b3af27d20ae1dea"></a><!-- doxytag: member="RakNet::BitStream::GetNumberOfUnreadBits" ref="7a853a0e55000f302b3af27d20ae1dea" args="(void) const " -->
BitSize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#7a853a0e55000f302b3af27d20ae1dea">GetNumberOfUnreadBits</a> (void) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Returns the number of bits left in the stream that haven't been read. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">BitSize_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#8471c4c11d6cc08bf713c8f8273d86b0">CopyData</a> (unsigned char **_data) const </td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes a copy of the internal data for you <em>_data</em> will point to the stream. Partial bytes are left aligned.  <a href="#8471c4c11d6cc08bf713c8f8273d86b0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned char *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#2e201444796178e5074083b6d09bd221">GetData</a> (void) const </td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#6357c08afed23e2e857c418cbbb3a29a">WriteBits</a> (const unsigned char *inByteArray, BitSize_t numberOfBitsToWrite, const bool rightAlignedBits=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write numberToWrite bits from the input source.  <a href="#6357c08afed23e2e857c418cbbb3a29a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#bcd8b1c73408fc1e4e8088ca858c0f7a">WriteAlignedBytes</a> (const unsigned char *inByteArray, const unsigned int numberOfBytesToWrite)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Align the bitstream to the byte boundary and then write the specified number of bits.  <a href="#bcd8b1c73408fc1e4e8088ca858c0f7a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#2ae285a7aaba6f50b5ce8e5bf4163639">WriteAlignedBytesSafe</a> (const char *inByteArray, const unsigned int inputLength, const unsigned int maxBytesToWrite)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Aligns the bitstream, writes inputLength, and writes input. Won't write beyond maxBytesToWrite.  <a href="#2ae285a7aaba6f50b5ce8e5bf4163639"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#1543023e7a84ecbf58a777aa2071b444">ReadAlignedBytes</a> (unsigned char *inOutByteArray, const unsigned int numberOfBytesToRead)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read bits, starting at the next aligned bits.  <a href="#1543023e7a84ecbf58a777aa2071b444"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#2fcd3b86367691647f66a81241358fe7">ReadAlignedBytesSafe</a> (char *inOutByteArray, int &amp;inputLength, const int maxBytesToRead)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads what was written by WriteAlignedBytesSafe.  <a href="#2fcd3b86367691647f66a81241358fe7"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#9ada145cbde1fb34dc4187b33ca5b4f6">ReadAlignedBytesSafeAlloc</a> (char **outByteArray, int &amp;inputLength, const unsigned int maxBytesToRead)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Same as <a class="el" href="classRakNet_1_1BitStream.html#2fcd3b86367691647f66a81241358fe7" title="Reads what was written by WriteAlignedBytesSafe.">ReadAlignedBytesSafe()</a> but allocates the memory for you using new, rather than assuming it is safe to write to.  <a href="#9ada145cbde1fb34dc4187b33ca5b4f6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#157d750a205462beb3b418ade252cf19">AlignWriteToByteBoundary</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Align the next write and/or read to a byte boundary.  <a href="#157d750a205462beb3b418ade252cf19"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#adbbeb19cf6b7fbb5c170ae366d4be30">AlignReadToByteBoundary</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Align the next write and/or read to a byte boundary.  <a href="#adbbeb19cf6b7fbb5c170ae366d4be30"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#386965784e4352212b047c1c3dcb51f3">ReadBits</a> (unsigned char *inOutByteArray, BitSize_t numberOfBitsToRead, const bool alignBitsToRight=true)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read <em>numberOfBitsToRead</em> bits to the output source.  <a href="#386965784e4352212b047c1c3dcb51f3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="d944a6707a90f1727bcc5ac8de2b58bd"></a><!-- doxytag: member="RakNet::BitStream::Write0" ref="d944a6707a90f1727bcc5ac8de2b58bd" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#d944a6707a90f1727bcc5ac8de2b58bd">Write0</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a 0. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="185c35c9ca1fc58057d9e94a025d3961"></a><!-- doxytag: member="RakNet::BitStream::Write1" ref="185c35c9ca1fc58057d9e94a025d3961" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#185c35c9ca1fc58057d9e94a025d3961">Write1</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a 1. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="48bf969fc517f2e568ce02c4a859cc27"></a><!-- doxytag: member="RakNet::BitStream::ReadBit" ref="48bf969fc517f2e568ce02c4a859cc27" args="(void)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#48bf969fc517f2e568ce02c4a859cc27">ReadBit</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads 1 bit and returns true if that bit is 1 and false if it is 0. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="0c4d4693f8fa98c3fa757da57fcb0c5d"></a><!-- doxytag: member="RakNet::BitStream::AssertCopyData" ref="0c4d4693f8fa98c3fa757da57fcb0c5d" args="(void)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#0c4d4693f8fa98c3fa757da57fcb0c5d">AssertCopyData</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">If we used the constructor version with copy data off, this makes sure it is set to on and the data pointed to is copied. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="ba6bd33c456e1593e002207bc3ec5c28"></a><!-- doxytag: member="RakNet::BitStream::SetNumberOfBitsAllocated" ref="ba6bd33c456e1593e002207bc3ec5c28" args="(const BitSize_t lengthInBits)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#ba6bd33c456e1593e002207bc3ec5c28">SetNumberOfBitsAllocated</a> (const BitSize_t lengthInBits)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Use this if you pass a pointer copy to the constructor (_copyData==false) and want to overallocate to prevent reallocation. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="8ee4d3114fcce22de87644241dcdd39b"></a><!-- doxytag: member="RakNet::BitStream::AddBitsAndReallocate" ref="8ee4d3114fcce22de87644241dcdd39b" args="(const BitSize_t numberOfBitsToWrite)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#8ee4d3114fcce22de87644241dcdd39b">AddBitsAndReallocate</a> (const BitSize_t numberOfBitsToWrite)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reallocates (if necessary) in preparation of writing numberOfBitsToWrite. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="c554b5dff8da17052d12ed620bb8cf53"></a><!-- doxytag: member="RakNet::BitStream::Read" ref="c554b5dff8da17052d12ed620bb8cf53" args="(char *varString)" -->
bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#c554b5dff8da17052d12ed620bb8cf53">Read</a> (char *varString)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read strings, non reference. <br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1517a13993e3b19f84692db75d1c162f"></a><!-- doxytag: member="RakNet::BitStream::PadWithZeroToByteLength" ref="1517a13993e3b19f84692db75d1c162f" args="(unsigned int bytes)" -->
void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#1517a13993e3b19f84692db75d1c162f">PadWithZeroToByteLength</a> (unsigned int bytes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write zeros until the bitstream is filled up to <em>bytes</em>. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#3124e2e59123caf4b383ee5092621775">Write</a> (const bool &amp;inTemplateVar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a bool to a bitstream.  <a href="#3124e2e59123caf4b383ee5092621775"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#94d26ac0f6bb22f975ad346f2a309e74">Write</a> (const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> &amp;inTemplateVar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a systemAddress to a bitstream.  <a href="#94d26ac0f6bb22f975ad346f2a309e74"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#7b2969415bef76788596fecc3d9505ab">Write</a> (const <a class="el" href="classRakNet_1_1RakString.html">RakString</a> &amp;inTemplateVar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a string to a bitstream.  <a href="#7b2969415bef76788596fecc3d9505ab"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#623543a19e73e94558a5bcae4435146d">WriteDelta</a> (const bool &amp;currentValue, const bool &amp;lastValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a bool delta. Same thing as just calling Write.  <a href="#623543a19e73e94558a5bcae4435146d"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="47277c4d6e4ba600c439bdae7cfc1718"></a><!-- doxytag: member="RakNet::BitStream::WriteCompressed" ref="47277c4d6e4ba600c439bdae7cfc1718" args="(const float &amp;inTemplateVar)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#47277c4d6e4ba600c439bdae7cfc1718">WriteCompressed</a> (const float &amp;inTemplateVar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For values between -1 and 1. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="71dcea9ed01204482587714dd0a851b5"></a><!-- doxytag: member="RakNet::BitStream::WriteCompressed" ref="71dcea9ed01204482587714dd0a851b5" args="(const double &amp;inTemplateVar)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#71dcea9ed01204482587714dd0a851b5">WriteCompressed</a> (const double &amp;inTemplateVar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For values between -1 and 1. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="8d1211e7c51514d4d395c082acc2fde9"></a><!-- doxytag: member="RakNet::BitStream::WriteCompressed" ref="8d1211e7c51514d4d395c082acc2fde9" args="(const RakString &amp;inTemplateVar)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#8d1211e7c51514d4d395c082acc2fde9">WriteCompressed</a> (const <a class="el" href="classRakNet_1_1RakString.html">RakString</a> &amp;inTemplateVar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compress the string. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#06e2877d7238d9675714eee221a144dd">WriteCompressedDelta</a> (const bool &amp;currentValue, const bool &amp;lastValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Write a bool delta. Same thing as just calling Write.  <a href="#06e2877d7238d9675714eee221a144dd"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="26cade602c73a0ac81e6b5a83fa7a7de"></a><!-- doxytag: member="RakNet::BitStream::WriteCompressedDelta" ref="26cade602c73a0ac81e6b5a83fa7a7de" args="(const bool &amp;currentValue)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#26cade602c73a0ac81e6b5a83fa7a7de">WriteCompressedDelta</a> (const bool &amp;currentValue)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Save as WriteCompressedDelta(bool currentValue, const templateType &amp;lastValue) when we have an unknown second bool. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a5d9610cd1447210faeddd97b0eef8d5">Read</a> (bool &amp;outTemplateVar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a bool from a bitstream.  <a href="#a5d9610cd1447210faeddd97b0eef8d5"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#a473c1bfa91437afd260d32554b76b17">Read</a> (<a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> &amp;outTemplateVar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a systemAddress from a bitstream.  <a href="#a473c1bfa91437afd260d32554b76b17"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#6f9bf8cb5cc6bb6ce8290f7b5a2a7b55">ReadDelta</a> (bool &amp;outTemplateVar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a bool from a bitstream.  <a href="#6f9bf8cb5cc6bb6ce8290f7b5a2a7b55"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="c9f50bcf9bf0b7fde6f92b54a353a254"></a><!-- doxytag: member="RakNet::BitStream::ReadCompressed" ref="c9f50bcf9bf0b7fde6f92b54a353a254" args="(float &amp;outTemplateVar)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#c9f50bcf9bf0b7fde6f92b54a353a254">ReadCompressed</a> (float &amp;outTemplateVar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For values between -1 and 1. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="d3b432107ccbed13988b2b2e9e5f35e4"></a><!-- doxytag: member="RakNet::BitStream::ReadCompressed" ref="d3b432107ccbed13988b2b2e9e5f35e4" args="(double &amp;outTemplateVar)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#d3b432107ccbed13988b2b2e9e5f35e4">ReadCompressed</a> (double &amp;outTemplateVar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For values between -1 and 1. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2"><a class="anchor" name="c6e19cf3bae877fa49f047bb7e560881"></a><!-- doxytag: member="RakNet::BitStream::ReadCompressed" ref="c6e19cf3bae877fa49f047bb7e560881" args="(RakString &amp;outTemplateVar)" -->
template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#c6e19cf3bae877fa49f047bb7e560881">ReadCompressed</a> (<a class="el" href="classRakNet_1_1RakString.html">RakString</a> &amp;outTemplateVar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">For strings. <br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#668b798433bce3bf8b3600b5083ba503">ReadCompressedDelta</a> (bool &amp;outTemplateVar)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Read a bool from a bitstream.  <a href="#668b798433bce3bf8b3600b5083ba503"></a><br></td></tr>
<tr><td colspan="2"><br><h2>Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#fc678e70ac2082d65c1b103436ca6b6f">NumberOfLeadingZeroes</a> (uint8_t x)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top"><a class="anchor" name="1ce179acbb0ca867dacd482013831a30"></a><!-- doxytag: member="RakNet::BitStream::DoEndianSwap" ref="1ce179acbb0ca867dacd482013831a30" args="(void)" -->
static bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRakNet_1_1BitStream.html#1ce179acbb0ca867dacd482013831a30">DoEndianSwap</a> (void)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">---- Member function template specialization declarations ---- <br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
This class allows you to write and read native types as a string of bits. <a class="el" href="classRakNet_1_1BitStream.html">BitStream</a> is used extensively throughout <a class="el" href="namespaceRakNet.html" title="Simple class to send changes between directories. In essence, a simple autopatcher...">RakNet</a> and is designed to be used by users as well. <dl class="see" compact><dt><b>See also:</b></dt><dd>BitStreamSample.txt </dd></dl>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" name="47b1c7ce200c4815bd2a42d454244bb4"></a><!-- doxytag: member="RakNet::BitStream::BitStream" ref="47b1c7ce200c4815bd2a42d454244bb4" args="(const unsigned int initialBytesToAllocate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RakNet::BitStream::BitStream           </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&nbsp;</td>
          <td class="paramname"> <em>initialBytesToAllocate</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Create the bitstream, with some number of bytes to immediately allocate. 
<p>
There is no benefit to calling this, unless you know exactly how many bytes you need and it is greater than BITSTREAM_STACK_ALLOCATION_SIZE. In that case all it does is save you one or more realloc calls. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>initialBytesToAllocate</em>&nbsp;</td><td>the number of bytes to pre-allocate. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="04a200eaf5b379cad2e30d5de15a2c9a"></a><!-- doxytag: member="RakNet::BitStream::BitStream" ref="04a200eaf5b379cad2e30d5de15a2c9a" args="(unsigned char *_data, const unsigned int lengthInBytes, bool _copyData)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RakNet::BitStream::BitStream           </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&nbsp;</td>
          <td class="paramname"> <em>lengthInBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>_copyData</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Initialize the <a class="el" href="classRakNet_1_1BitStream.html">BitStream</a>, immediately setting the data it contains to a predefined pointer. 
<p>
Set <em>_copyData</em> to true if you want to make an internal copy of the data you are passing. Set it to false to just save a pointer to the data. You shouldn't call Write functions with <em>_copyData</em> as false, as this will write to unallocated memory 99% of the time you will use this function to cast <a class="el" href="structRakNet_1_1Packet.html#63e46b85c8ca156b205a124e54659614" title="The data from the sender.">Packet::data</a> to a bitstream for reading, in which case you should write something as follows: <div class="fragment"><pre class="fragment"> <a class="code" href="classRakNet_1_1BitStream.html">RakNet::BitStream</a> bs(packet-&gt;data, packet-&gt;length, <span class="keyword">false</span>);
</pre></div> <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>_data</em>&nbsp;</td><td>An array of bytes. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lengthInBytes</em>&nbsp;</td><td>Size of the <em>_data</em>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>_copyData</em>&nbsp;</td><td>true or false to make a copy of <em>_data</em> or not. </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr><h2>Member Function Documentation</h2>
<a class="anchor" name="adbbeb19cf6b7fbb5c170ae366d4be30"></a><!-- doxytag: member="RakNet::BitStream::AlignReadToByteBoundary" ref="adbbeb19cf6b7fbb5c170ae366d4be30" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::AlignReadToByteBoundary           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Align the next write and/or read to a byte boundary. 
<p>
This can be used to 'waste' bits to byte align for efficiency reasons It can also be used to force coalesced bitstreams to start on byte boundaries so so WriteAlignedBits and ReadAlignedBits both calculate the same offset when aligning. 
</div>
</div><p>
<a class="anchor" name="157d750a205462beb3b418ade252cf19"></a><!-- doxytag: member="RakNet::BitStream::AlignWriteToByteBoundary" ref="157d750a205462beb3b418ade252cf19" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::AlignWriteToByteBoundary           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Align the next write and/or read to a byte boundary. 
<p>
This can be used to 'waste' bits to byte align for efficiency reasons It can also be used to force coalesced bitstreams to start on byte boundaries so so WriteAlignedBits and ReadAlignedBits both calculate the same offset when aligning. 
</div>
</div><p>
<a class="anchor" name="8471c4c11d6cc08bf713c8f8273d86b0"></a><!-- doxytag: member="RakNet::BitStream::CopyData" ref="8471c4c11d6cc08bf713c8f8273d86b0" args="(unsigned char **_data) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">BitSize_t RakNet::BitStream::CopyData           </td>
          <td>(</td>
          <td class="paramtype">unsigned char **&nbsp;</td>
          <td class="paramname"> <em>_data</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Makes a copy of the internal data for you <em>_data</em> will point to the stream. Partial bytes are left aligned. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>_data</em>&nbsp;</td><td>The allocated copy of <a class="el" href="classRakNet_1_1BitStream.html#2e201444796178e5074083b6d09bd221">GetData()</a> </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>The length in bits of the stream. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2e201444796178e5074083b6d09bd221"></a><!-- doxytag: member="RakNet::BitStream::GetData" ref="2e201444796178e5074083b6d09bd221" args="(void) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char* RakNet::BitStream::GetData           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the data that <a class="el" href="classRakNet_1_1BitStream.html">BitStream</a> is writing to / reading from. Partial bytes are left aligned. <dl class="return" compact><dt><b>Returns:</b></dt><dd>A pointer to the internal state </dd></dl>

</div>
</div><p>
<a class="anchor" name="1952b3b3007b120fdd143f87311a98a2"></a><!-- doxytag: member="RakNet::BitStream::IgnoreBits" ref="1952b3b3007b120fdd143f87311a98a2" args="(const BitSize_t numberOfBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::IgnoreBits           </td>
          <td>(</td>
          <td class="paramtype">const BitSize_t&nbsp;</td>
          <td class="paramname"> <em>numberOfBits</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Ignore data we don't intend to read. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numberOfBits</em>&nbsp;</td><td>The number of bits to ignore </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="26310ba75436c24a1272e65da6a90a1e"></a><!-- doxytag: member="RakNet::BitStream::IgnoreBytes" ref="26310ba75436c24a1272e65da6a90a1e" args="(const unsigned int numberOfBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::IgnoreBytes           </td>
          <td>(</td>
          <td class="paramtype">const unsigned int&nbsp;</td>
          <td class="paramname"> <em>numberOfBytes</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Ignore data we don't intend to read. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numberOfBits</em>&nbsp;</td><td>The number of bytes to ignore </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fc678e70ac2082d65c1b103436ca6b6f"></a><!-- doxytag: member="RakNet::BitStream::NumberOfLeadingZeroes" ref="fc678e70ac2082d65c1b103436ca6b6f" args="(uint8_t x)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static int RakNet::BitStream::NumberOfLeadingZeroes           </td>
          <td>(</td>
          <td class="paramtype">uint8_t&nbsp;</td>
          <td class="paramname"> <em>x</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Get the number of leading zeros for a number <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>x</em>&nbsp;</td><td>Number to test </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a473c1bfa91437afd260d32554b76b17"></a><!-- doxytag: member="RakNet::BitStream::Read" ref="a473c1bfa91437afd260d32554b76b17" args="(SystemAddress &amp;outTemplateVar)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::Read           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>outTemplateVar</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read a systemAddress from a bitstream. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>outTemplateVar</em>&nbsp;</td><td>The value to read </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="a5d9610cd1447210faeddd97b0eef8d5"></a><!-- doxytag: member="RakNet::BitStream::Read" ref="a5d9610cd1447210faeddd97b0eef8d5" args="(bool &amp;outTemplateVar)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::Read           </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>outTemplateVar</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read a bool from a bitstream. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>outTemplateVar</em>&nbsp;</td><td>The value to read </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="25b53ddc6f6bc9a1e0c01cb677a3c6d1"></a><!-- doxytag: member="RakNet::BitStream::Read" ref="25b53ddc6f6bc9a1e0c01cb677a3c6d1" args="(char *output, const unsigned int numberOfBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::Read           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>output</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&nbsp;</td>
          <td class="paramname"> <em>numberOfBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read an array or casted stream of byte. 
<p>
The array is raw data. There is no automatic endian conversion with this function <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>output</em>&nbsp;</td><td>The result byte array. It should be larger than <em>numberOfBytes</em>. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numberOfBytes</em>&nbsp;</td><td>The number of byte to read </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true on success false if there is some missing bytes. </dd></dl>

</div>
</div><p>
<a class="anchor" name="025f73d57a5ebe8fb6393eca5f3616df"></a><!-- doxytag: member="RakNet::BitStream::Read" ref="025f73d57a5ebe8fb6393eca5f3616df" args="(BitStream *bitStream, BitSize_t numberOfBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::Read           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRakNet_1_1BitStream.html">BitStream</a> *&nbsp;</td>
          <td class="paramname"> <em>bitStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BitSize_t&nbsp;</td>
          <td class="paramname"> <em>numberOfBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read one bitstream to another. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numberOfBits</em>&nbsp;</td><td>bits to read </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bitStream</em>&nbsp;</td><td>the bitstream to read into from </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true on success, false on failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="45c9d2484823bb62430ded4d7eeda201"></a><!-- doxytag: member="RakNet::BitStream::Read" ref="45c9d2484823bb62430ded4d7eeda201" args="(templateType &amp;outTemplateVar)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::Read           </td>
          <td>(</td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>outTemplateVar</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read any integral type from a bitstream. 
<p>
Read any integral type from a bitstream. Define __BITSTREAM_NATIVE_END if you need endian swapping.<p>
Define __BITSTREAM_NATIVE_END if you need endian swapping. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>outTemplateVar</em>&nbsp;</td><td>The value to read </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true on success, false on failure.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>outTemplateVar</em>&nbsp;</td><td>The value to read </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="1543023e7a84ecbf58a777aa2071b444"></a><!-- doxytag: member="RakNet::BitStream::ReadAlignedBytes" ref="1543023e7a84ecbf58a777aa2071b444" args="(unsigned char *inOutByteArray, const unsigned int numberOfBytesToRead)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::ReadAlignedBytes           </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>inOutByteArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&nbsp;</td>
          <td class="paramname"> <em>numberOfBytesToRead</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read bits, starting at the next aligned bits. 
<p>
Note that the modulus 8 starting offset of the sequence must be the same as was used with WriteBits. This will be a problem with packet coalescence unless you byte align the coalesced packets. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inOutByteArray</em>&nbsp;</td><td>The byte array larger than <em>numberOfBytesToRead</em> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numberOfBytesToRead</em>&nbsp;</td><td>The number of byte to read from the internal state </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if there is enough byte. </dd></dl>

</div>
</div><p>
<a class="anchor" name="2fcd3b86367691647f66a81241358fe7"></a><!-- doxytag: member="RakNet::BitStream::ReadAlignedBytesSafe" ref="2fcd3b86367691647f66a81241358fe7" args="(char *inOutByteArray, int &amp;inputLength, const int maxBytesToRead)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::ReadAlignedBytesSafe           </td>
          <td>(</td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>inOutByteArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>inputLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>maxBytesToRead</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads what was written by WriteAlignedBytesSafe. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inOutByteArray</em>&nbsp;</td><td>The data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxBytesToRead</em>&nbsp;</td><td>Maximum number of bytes to read </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true on success, false on failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="9ada145cbde1fb34dc4187b33ca5b4f6"></a><!-- doxytag: member="RakNet::BitStream::ReadAlignedBytesSafeAlloc" ref="9ada145cbde1fb34dc4187b33ca5b4f6" args="(char **outByteArray, int &amp;inputLength, const unsigned int maxBytesToRead)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::ReadAlignedBytesSafeAlloc           </td>
          <td>(</td>
          <td class="paramtype">char **&nbsp;</td>
          <td class="paramname"> <em>outByteArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&nbsp;</td>
          <td class="paramname"> <em>inputLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&nbsp;</td>
          <td class="paramname"> <em>maxBytesToRead</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Same as <a class="el" href="classRakNet_1_1BitStream.html#2fcd3b86367691647f66a81241358fe7" title="Reads what was written by WriteAlignedBytesSafe.">ReadAlignedBytesSafe()</a> but allocates the memory for you using new, rather than assuming it is safe to write to. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>outByteArray</em>&nbsp;</td><td>outByteArray will be deleted if it is not a pointer to 0 </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true on success, false on failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="386965784e4352212b047c1c3dcb51f3"></a><!-- doxytag: member="RakNet::BitStream::ReadBits" ref="386965784e4352212b047c1c3dcb51f3" args="(unsigned char *inOutByteArray, BitSize_t numberOfBitsToRead, const bool alignBitsToRight=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::ReadBits           </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>inOutByteArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BitSize_t&nbsp;</td>
          <td class="paramname"> <em>numberOfBitsToRead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>alignBitsToRight</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read <em>numberOfBitsToRead</em> bits to the output source. 
<p>
alignBitsToRight should be set to true to convert internal bitstream data to userdata. It should be false if you used WriteBits with rightAlignedBits false <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inOutByteArray</em>&nbsp;</td><td>The resulting bits array </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numberOfBitsToRead</em>&nbsp;</td><td>The number of bits to read </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>alignBitsToRight</em>&nbsp;</td><td>if true bits will be right aligned. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if there is enough bits to read </dd></dl>

</div>
</div><p>
<a class="anchor" name="092f9780c4fa69b93e1ea3d89fb4d322"></a><!-- doxytag: member="RakNet::BitStream::ReadBitsFromIntegerRange" ref="092f9780c4fa69b93e1ea3d89fb4d322" args="(templateType &amp;value, const templateType minimum, const templateType maximum, const int requiredBits, bool allowOutsideRange=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::ReadBitsFromIntegerRange           </td>
          <td>(</td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const templateType&nbsp;</td>
          <td class="paramname"> <em>minimum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const templateType&nbsp;</td>
          <td class="paramname"> <em>maximum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>requiredBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>allowOutsideRange</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>requiredBits</em>&nbsp;</td><td>Primarily for internal use, called from above function() after calculating number of bits needed to represent maximum-minimum </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ac098d281b3d2f2eb193b99d7bc50956"></a><!-- doxytag: member="RakNet::BitStream::ReadBitsFromIntegerRange" ref="ac098d281b3d2f2eb193b99d7bc50956" args="(templateType &amp;value, const templateType minimum, const templateType maximum, bool allowOutsideRange=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::ReadBitsFromIntegerRange           </td>
          <td>(</td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const templateType&nbsp;</td>
          <td class="paramname"> <em>minimum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const templateType&nbsp;</td>
          <td class="paramname"> <em>maximum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>allowOutsideRange</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given the minimum and maximum values for an integer type, figure out the minimum number of bits to represent the range Then read only those bits <dl class="note" compact><dt><b>Note:</b></dt><dd>A static is used so that the required number of bits for (maximum-minimum) is only calculated once. This does require that <em>minimum</em> and  are fixed values for a given line of code for the life of the program </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Integer value to read, which should be between <em>minimum</em> and <em>maximum</em> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>minimum</em>&nbsp;</td><td>Minimum value of <em>value</em> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maximum</em>&nbsp;</td><td>Maximum value of <em>value</em> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>allowOutsideRange</em>&nbsp;</td><td>If true, all sends will take an extra bit, however value can deviate from outside <em>minimum</em> and <em>maximum</em>. If false, will assert if the value deviates. This should match the corresponding value passed to <a class="el" href="classRakNet_1_1BitStream.html#260675ffb5cb824cbed3465b0319383c" title="Write any integral type to a bitstream.">Write()</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="fd466ad5445d355be0c6c9435eb602bd"></a><!-- doxytag: member="RakNet::BitStream::ReadCasted" ref="fd466ad5445d355be0c6c9435eb602bd" args="(sourceType &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class serializationType , class sourceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::ReadCasted           </td>
          <td>(</td>
          <td class="paramtype">sourceType &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read one type serialized to another (smaller) type, to save bandwidth serializationType should be uint8_t, uint16_t, uint24_t, or uint32_t Example: int num; ReadCasted&lt;uint8_t&gt;(num); would read 1 bytefrom the stream, and put the value in an integer <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>The value to write </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c8f5c1748ce9fdf797cc9e8e8bdd082f"></a><!-- doxytag: member="RakNet::BitStream::ReadCompressed" ref="c8f5c1748ce9fdf797cc9e8e8bdd082f" args="(templateType &amp;outTemplateVar)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::ReadCompressed           </td>
          <td>(</td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>outTemplateVar</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read any integral type from a bitstream. 
<p>
Undefine __BITSTREAM_NATIVE_END if you need endian swapping. For floating point, this is lossy, using 2 bytes for a float and 4 for a double. The range must be between -1 and +1. For non-floating point, this is lossless, but only has benefit if you use less than half the bits of the type If you are not using __BITSTREAM_NATIVE_END the opposite is true for types larger than 1 byte <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>outTemplateVar</em>&nbsp;</td><td>The value to read </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true on success, false on failure.</dd></dl>
Undefine __BITSTREAM_NATIVE_END if you need endian swapping. For floating point, this is lossy, using 2 bytes for a float and 4 for a double. The range must be between -1 and +1. For non-floating point, this is lossless, but only has benefit if you use less than half the bits of the type If you are not using __BITSTREAM_NATIVE_END the opposite is true for types larger than 1 byte <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>outTemplateVar</em>&nbsp;</td><td>The value to read </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="668b798433bce3bf8b3600b5083ba503"></a><!-- doxytag: member="RakNet::BitStream::ReadCompressedDelta" ref="668b798433bce3bf8b3600b5083ba503" args="(bool &amp;outTemplateVar)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::ReadCompressedDelta           </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>outTemplateVar</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read a bool from a bitstream. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>outTemplateVar</em>&nbsp;</td><td>The value to read </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ac829439f72872ee3962509e19440b11"></a><!-- doxytag: member="RakNet::BitStream::ReadCompressedDelta" ref="ac829439f72872ee3962509e19440b11" args="(templateType &amp;outTemplateVar)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::ReadCompressedDelta           </td>
          <td>(</td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>outTemplateVar</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read any integral type from a bitstream. 
<p>
If the written value differed from the value compared against in the write function, var will be updated. Otherwise it will retain the current value. the current value will be updated. For floating point, this is lossy, using 2 bytes for a float and 4 for a double. The range must be between -1 and +1. For non-floating point, this is lossless, but only has benefit if you use less than half the bits of the type If you are not using __BITSTREAM_NATIVE_END the opposite is true for types larger than 1 byte ReadCompressedDelta is only valid from a previous call to WriteDelta <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>outTemplateVar</em>&nbsp;</td><td>The value to read </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true on success, false on failure.</dd></dl>
If the written value differed from the value compared against in the write function, var will be updated. Otherwise it will retain the current value. the current value will be updated. For floating point, this is lossy, using 2 bytes for a float and 4 for a double. The range must be between -1 and +1. For non-floating point, this is lossless, but only has benefit if you use less than half the bits of the type If you are not using __BITSTREAM_NATIVE_END the opposite is true for types larger than 1 byte ReadCompressedDelta is only valid from a previous call to WriteDelta <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>outTemplateVar</em>&nbsp;</td><td>The value to read </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6f9bf8cb5cc6bb6ce8290f7b5a2a7b55"></a><!-- doxytag: member="RakNet::BitStream::ReadDelta" ref="6f9bf8cb5cc6bb6ce8290f7b5a2a7b55" args="(bool &amp;outTemplateVar)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::ReadDelta           </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&nbsp;</td>
          <td class="paramname"> <em>outTemplateVar</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read a bool from a bitstream. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>outTemplateVar</em>&nbsp;</td><td>The value to read </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="e1fa85a18abdabca0818e3e8a6e9bd1b"></a><!-- doxytag: member="RakNet::BitStream::ReadDelta" ref="e1fa85a18abdabca0818e3e8a6e9bd1b" args="(templateType &amp;outTemplateVar)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::ReadDelta           </td>
          <td>(</td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>outTemplateVar</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read any integral type from a bitstream. 
<p>
If the written value differed from the value compared against in the write function, var will be updated. Otherwise it will retain the current value. ReadDelta is only valid from a previous call to WriteDelta <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>outTemplateVar</em>&nbsp;</td><td>The value to read </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true on success, false on failure.</dd></dl>
If the written value differed from the value compared against in the write function, var will be updated. Otherwise it will retain the current value. ReadDelta is only valid from a previous call to WriteDelta <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>outTemplateVar</em>&nbsp;</td><td>The value to read </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f8275d390e2114d55449bb4ae2d01d62"></a><!-- doxytag: member="RakNet::BitStream::ReadFloat16" ref="f8275d390e2114d55449bb4ae2d01d62" args="(float &amp;outFloat, float floatMin, float floatMax)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::ReadFloat16           </td>
          <td>(</td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>outFloat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>floatMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>floatMax</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read a float into 2 bytes, spanning the range between <em>floatMin</em> and <em>floatMax</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>outFloat</em>&nbsp;</td><td>The float to read </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>floatMin</em>&nbsp;</td><td>Predetermined minimum value of f </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>floatMax</em>&nbsp;</td><td>Predetermined maximum value of f </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="492d3b89ce89aafa804f99aa6e432be1"></a><!-- doxytag: member="RakNet::BitStream::ReadNormQuat" ref="492d3b89ce89aafa804f99aa6e432be1" args="(templateType &amp;w, templateType &amp;x, templateType &amp;y, templateType &amp;z)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::ReadNormQuat           </td>
          <td>(</td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read a normalized quaternion in 6 bytes + 4 bits instead of 16 bytes. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>w</em>&nbsp;</td><td>w </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>x</em>&nbsp;</td><td>x </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>y</em>&nbsp;</td><td>y </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>z</em>&nbsp;</td><td>z </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true on success, false on failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3fe2307474325b610e2571d741c3ff5b"></a><!-- doxytag: member="RakNet::BitStream::ReadNormVector" ref="3fe2307474325b610e2571d741c3ff5b" args="(templateType &amp;x, templateType &amp;y, templateType &amp;z)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::ReadNormVector           </td>
          <td>(</td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read a normalized 3D vector, using (at most) 4 bytes + 3 bits instead of 12-24 bytes. 
<p>
Will further compress y or z axis aligned vectors. Accurate to 1/32767.5. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>x</em>&nbsp;</td><td>x </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>y</em>&nbsp;</td><td>y </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>z</em>&nbsp;</td><td>z </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true on success, false on failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e6e4c9a69605709d5a449425ecad37fa"></a><!-- doxytag: member="RakNet::BitStream::ReadOrthMatrix" ref="e6e4c9a69605709d5a449425ecad37fa" args="(templateType &amp;m00, templateType &amp;m01, templateType &amp;m02, templateType &amp;m10, templateType &amp;m11, templateType &amp;m12, templateType &amp;m20, templateType &amp;m21, templateType &amp;m22)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::ReadOrthMatrix           </td>
          <td>(</td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>m00</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>m01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>m02</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>m10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>m11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>m12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>m20</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>m21</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>m22</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read an orthogonal matrix from a quaternion, reading 3 components of the quaternion in 2 bytes each and extrapolatig the 4th. 
<p>
Use 6 bytes instead of 36 Lossy, although the result is renormalized <dl class="return" compact><dt><b>Returns:</b></dt><dd>true on success, false on failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5c22e455ff1ca1532faf709c2266815f"></a><!-- doxytag: member="RakNet::BitStream::ReadVector" ref="5c22e455ff1ca1532faf709c2266815f" args="(templateType &amp;x, templateType &amp;y, templateType &amp;z)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::ReadVector           </td>
          <td>(</td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Read 3 floats or doubles, using 10 bytes, where those float or doubles comprise a vector. 
<p>
Loses accuracy to about 3/10ths and only saves 2 bytes, so only use if accuracy is not important. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>x</em>&nbsp;</td><td>x </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>y</em>&nbsp;</td><td>y </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>z</em>&nbsp;</td><td>z </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true on success, false on failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d2e3ec310191a69b9bba227a72e65537"></a><!-- doxytag: member="RakNet::BitStream::Serialize" ref="d2e3ec310191a69b9bba227a72e65537" args="(bool writeToBitstream, char *inOutByteArray, const unsigned int numberOfBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::Serialize           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>writeToBitstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&nbsp;</td>
          <td class="paramname"> <em>inOutByteArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&nbsp;</td>
          <td class="paramname"> <em>numberOfBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bidirectional serialize/deserialize an array or casted stream or raw data. This does NOT do endian swapping. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>writeToBitstream</em>&nbsp;</td><td>true to write from your data to this bitstream. False to read from this bitstream and write to your data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inOutByteArray</em>&nbsp;</td><td>a byte buffer </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numberOfBytes</em>&nbsp;</td><td>the size of <em>input</em> in bytes </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if <em>writeToBitstream</em> is true. true if <em>writeToBitstream</em> is false and the read was successful. false if <em>writeToBitstream</em> is false and the read was not successful. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d2e1037f884caf1b8bc965655a4ee1f6"></a><!-- doxytag: member="RakNet::BitStream::Serialize" ref="d2e1037f884caf1b8bc965655a4ee1f6" args="(bool writeToBitstream, templateType &amp;inOutTemplateVar)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::Serialize           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>writeToBitstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>inOutTemplateVar</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bidirectional serialize/deserialize any integral type to/from a bitstream. 
<p>
Undefine __BITSTREAM_NATIVE_END if you need endian swapping. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>writeToBitstream</em>&nbsp;</td><td>true to write from your data to this bitstream. False to read from this bitstream and write to your data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inOutTemplateVar</em>&nbsp;</td><td>The value to write </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if <em>writeToBitstream</em> is true. true if <em>writeToBitstream</em> is false and the read was successful. false if <em>writeToBitstream</em> is false and the read was not successful. </dd></dl>

</div>
</div><p>
<a class="anchor" name="25c0f31d16b211a2aa7cdb3ec594cbf9"></a><!-- doxytag: member="RakNet::BitStream::SerializeBits" ref="25c0f31d16b211a2aa7cdb3ec594cbf9" args="(bool writeToBitstream, unsigned char *inOutByteArray, const BitSize_t numberOfBitsToSerialize, const bool rightAlignedBits=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::SerializeBits           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>writeToBitstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char *&nbsp;</td>
          <td class="paramname"> <em>inOutByteArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BitSize_t&nbsp;</td>
          <td class="paramname"> <em>numberOfBitsToSerialize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>rightAlignedBits</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bidirectional serialize/deserialize numberToSerialize bits to/from the input. 
<p>
Right aligned data means in the case of a partial byte, the bits are aligned from the right (bit 0) rather than the left (as in the normal internal representation) You would set this to true when writing user data, and false when copying bitstream data, such as writing one bitstream to another <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>writeToBitstream</em>&nbsp;</td><td>true to write from your data to this bitstream. False to read from this bitstream and write to your data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inOutByteArray</em>&nbsp;</td><td>The data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numberOfBitsToSerialize</em>&nbsp;</td><td>The number of bits to write </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rightAlignedBits</em>&nbsp;</td><td>if true data will be right aligned </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if <em>writeToBitstream</em> is true. true if <em>writeToBitstream</em> is false and the read was successful. false if <em>writeToBitstream</em> is false and the read was not successful. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fc3e191bc13f1e9a768fa5073c74a4eb"></a><!-- doxytag: member="RakNet::BitStream::SerializeBitsFromIntegerRange" ref="fc3e191bc13f1e9a768fa5073c74a4eb" args="(bool writeToBitstream, templateType &amp;value, const templateType minimum, const templateType maximum, const int requiredBits, bool allowOutsideRange=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::SerializeBitsFromIntegerRange           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>writeToBitstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const templateType&nbsp;</td>
          <td class="paramname"> <em>minimum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const templateType&nbsp;</td>
          <td class="paramname"> <em>maximum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>requiredBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>allowOutsideRange</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>requiredBits</em>&nbsp;</td><td>Primarily for internal use, called from above function() after calculating number of bits needed to represent maximum-minimum </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8718889282a4aee473ef48efe4934fd5"></a><!-- doxytag: member="RakNet::BitStream::SerializeBitsFromIntegerRange" ref="8718889282a4aee473ef48efe4934fd5" args="(bool writeToBitstream, templateType &amp;value, const templateType minimum, const templateType maximum, bool allowOutsideRange=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::SerializeBitsFromIntegerRange           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>writeToBitstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const templateType&nbsp;</td>
          <td class="paramname"> <em>minimum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const templateType&nbsp;</td>
          <td class="paramname"> <em>maximum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>allowOutsideRange</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given the minimum and maximum values for an integer type, figure out the minimum number of bits to represent the range Then serialize only those bits <dl class="note" compact><dt><b>Note:</b></dt><dd>A static is used so that the required number of bits for (maximum-minimum) is only calculated once. This does require that <em>minimum</em> and  are fixed values for a given line of code for the life of the program </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>writeToBitstream</em>&nbsp;</td><td>true to write from your data to this bitstream. False to read from this bitstream and write to your data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Integer value to write, which should be between <em>minimum</em> and <em>maximum</em> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>minimum</em>&nbsp;</td><td>Minimum value of <em>value</em> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maximum</em>&nbsp;</td><td>Maximum value of <em>value</em> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>allowOutsideRange</em>&nbsp;</td><td>If true, all sends will take an extra bit, however value can deviate from outside <em>minimum</em> and <em>maximum</em>. If false, will assert if the value deviates </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="180c7177b56b1afaf58c671e2ac9cafc"></a><!-- doxytag: member="RakNet::BitStream::SerializeCasted" ref="180c7177b56b1afaf58c671e2ac9cafc" args="(bool writeToBitstream, sourceType &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class serializationType , class sourceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::SerializeCasted           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>writeToBitstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sourceType &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Serialize one type casted to another (smaller) type, to save bandwidth serializationType should be uint8_t, uint16_t, uint24_t, or uint32_t Example: int num=53; SerializeCasted&lt;uint8_t&gt;(true, num); would use 1 byte to write what would otherwise be an integer (4 or 8 bytes) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>writeToBitstream</em>&nbsp;</td><td>true to write from your data to this bitstream. False to read from this bitstream and write to your data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>The value to serialize </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f961981b0774a90109a765b08eecd019"></a><!-- doxytag: member="RakNet::BitStream::SerializeCompressed" ref="f961981b0774a90109a765b08eecd019" args="(bool writeToBitstream, templateType &amp;inOutTemplateVar)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::SerializeCompressed           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>writeToBitstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>inOutTemplateVar</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bidirectional serialize/deserialize any integral type to/from a bitstream. 
<p>
Undefine __BITSTREAM_NATIVE_END if you need endian swapping. If you are not using __BITSTREAM_NATIVE_END the opposite is true for types larger than 1 byte For floating point, this is lossy, using 2 bytes for a float and 4 for a double. The range must be between -1 and +1. For non-floating point, this is lossless, but only has benefit if you use less than half the bits of the type <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>writeToBitstream</em>&nbsp;</td><td>true to write from your data to this bitstream. False to read from this bitstream and write to your data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inOutTemplateVar</em>&nbsp;</td><td>The value to write </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if <em>writeToBitstream</em> is true. true if <em>writeToBitstream</em> is false and the read was successful. false if <em>writeToBitstream</em> is false and the read was not successful. </dd></dl>

</div>
</div><p>
<a class="anchor" name="cbd582bb54666cd9e6e58f708df9ca65"></a><!-- doxytag: member="RakNet::BitStream::SerializeCompressedDelta" ref="cbd582bb54666cd9e6e58f708df9ca65" args="(bool writeToBitstream, templateType &amp;inOutTemplateVar)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::SerializeCompressedDelta           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>writeToBitstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>inOutTemplateVar</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Save as SerializeCompressedDelta(templateType &amp;currentValue, const templateType &amp;lastValue) when we have an unknown second parameter. 
<p>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true on data read. False on insufficient data in bitstream </dd></dl>

</div>
</div><p>
<a class="anchor" name="80d6eb64fd0a336b2572a2cb3c3dfad1"></a><!-- doxytag: member="RakNet::BitStream::SerializeCompressedDelta" ref="80d6eb64fd0a336b2572a2cb3c3dfad1" args="(bool writeToBitstream, templateType &amp;inOutCurrentValue, const templateType &amp;lastValue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::SerializeCompressedDelta           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>writeToBitstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>inOutCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>lastValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bidirectional serialize/deserialize any integral type to/from a bitstream. 
<p>
If the current value is different from the last value the current value will be written. Otherwise, a single bit will be written For floating point, this is lossy, using 2 bytes for a float and 4 for a double. The range must be between -1 and +1. For non-floating point, this is lossless, but only has benefit if you use less than half the bits of the type If you are not using __BITSTREAM_NATIVE_END the opposite is true for types larger than 1 byte <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>writeToBitstream</em>&nbsp;</td><td>true to write from your data to this bitstream. False to read from this bitstream and write to your data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inOutCurrentValue</em>&nbsp;</td><td>The current value to write </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lastValue</em>&nbsp;</td><td>The last value to compare against. Only used if <em>writeToBitstream</em> is true. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if <em>writeToBitstream</em> is true. true if <em>writeToBitstream</em> is false and the read was successful. false if <em>writeToBitstream</em> is false and the read was not successful. </dd></dl>

</div>
</div><p>
<a class="anchor" name="776115b23e4e15af05c46003d2d2d2b4"></a><!-- doxytag: member="RakNet::BitStream::SerializeDelta" ref="776115b23e4e15af05c46003d2d2d2b4" args="(bool writeToBitstream, templateType &amp;inOutCurrentValue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::SerializeDelta           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>writeToBitstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>inOutCurrentValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bidirectional version of SerializeDelta when you don't know what the last value is, or there is no last value. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>writeToBitstream</em>&nbsp;</td><td>true to write from your data to this bitstream. False to read from this bitstream and write to your data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inOutCurrentValue</em>&nbsp;</td><td>The current value to write </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if <em>writeToBitstream</em> is true. true if <em>writeToBitstream</em> is false and the read was successful. false if <em>writeToBitstream</em> is false and the read was not successful. </dd></dl>

</div>
</div><p>
<a class="anchor" name="27ecb5bf560591d9dc99d329be2a59f0"></a><!-- doxytag: member="RakNet::BitStream::SerializeDelta" ref="27ecb5bf560591d9dc99d329be2a59f0" args="(bool writeToBitstream, templateType &amp;inOutCurrentValue, const templateType &amp;lastValue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::SerializeDelta           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>writeToBitstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>inOutCurrentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>lastValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bidirectional serialize/deserialize any integral type to/from a bitstream. 
<p>
If the current value is different from the last value the current value will be written. Otherwise, a single bit will be written <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>writeToBitstream</em>&nbsp;</td><td>true to write from your data to this bitstream. False to read from this bitstream and write to your data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inOutCurrentValue</em>&nbsp;</td><td>The current value to write </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lastValue</em>&nbsp;</td><td>The last value to compare against. Only used if <em>writeToBitstream</em> is true. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if <em>writeToBitstream</em> is true. true if <em>writeToBitstream</em> is false and the read was successful. false if <em>writeToBitstream</em> is false and the read was not successful. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1aebab1c543acd21742f380c95255365"></a><!-- doxytag: member="RakNet::BitStream::SerializeFloat16" ref="1aebab1c543acd21742f380c95255365" args="(bool writeToBitstream, float &amp;inOutFloat, float floatMin, float floatMax)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::SerializeFloat16           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>writeToBitstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float &amp;&nbsp;</td>
          <td class="paramname"> <em>inOutFloat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>floatMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>floatMax</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Serialize a float into 2 bytes, spanning the range between <em>floatMin</em> and <em>floatMax</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>writeToBitstream</em>&nbsp;</td><td>true to write from your data to this bitstream. False to read from this bitstream and write to your data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inOutFloat</em>&nbsp;</td><td>The float to write </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>floatMin</em>&nbsp;</td><td>Predetermined minimum value of f </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>floatMax</em>&nbsp;</td><td>Predetermined maximum value of f </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="885aa48b92f84f386d2e22902c0b20ca"></a><!-- doxytag: member="RakNet::BitStream::SerializeNormQuat" ref="885aa48b92f84f386d2e22902c0b20ca" args="(bool writeToBitstream, templateType &amp;w, templateType &amp;x, templateType &amp;y, templateType &amp;z)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::SerializeNormQuat           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>writeToBitstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bidirectional serialize/deserialize a normalized quaternion in 6 bytes + 4 bits instead of 16 bytes. Slightly lossy. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>writeToBitstream</em>&nbsp;</td><td>true to write from your data to this bitstream. False to read from this bitstream and write to your data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>w</em>&nbsp;</td><td>w </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>x</em>&nbsp;</td><td>x </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>y</em>&nbsp;</td><td>y </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>z</em>&nbsp;</td><td>z </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if <em>writeToBitstream</em> is true. true if <em>writeToBitstream</em> is false and the read was successful. false if <em>writeToBitstream</em> is false and the read was not successful. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d4fec447540af6e5959c0335bd2b0f18"></a><!-- doxytag: member="RakNet::BitStream::SerializeNormVector" ref="d4fec447540af6e5959c0335bd2b0f18" args="(bool writeToBitstream, templateType &amp;x, templateType &amp;y, templateType &amp;z)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::SerializeNormVector           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>writeToBitstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bidirectional serialize/deserialize a normalized 3D vector, using (at most) 4 bytes + 3 bits instead of 12-24 bytes. 
<p>
Will further compress y or z axis aligned vectors. Accurate to 1/32767.5. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>writeToBitstream</em>&nbsp;</td><td>true to write from your data to this bitstream. False to read from this bitstream and write to your data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>x</em>&nbsp;</td><td>x </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>y</em>&nbsp;</td><td>y </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>z</em>&nbsp;</td><td>z </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if <em>writeToBitstream</em> is true. true if <em>writeToBitstream</em> is false and the read was successful. false if <em>writeToBitstream</em> is false and the read was not successful. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c46a69cb205c73377be00b31fa78699e"></a><!-- doxytag: member="RakNet::BitStream::SerializeOrthMatrix" ref="c46a69cb205c73377be00b31fa78699e" args="(bool writeToBitstream, templateType &amp;m00, templateType &amp;m01, templateType &amp;m02, templateType &amp;m10, templateType &amp;m11, templateType &amp;m12, templateType &amp;m20, templateType &amp;m21, templateType &amp;m22)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::SerializeOrthMatrix           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>writeToBitstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>m00</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>m01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>m02</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>m10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>m11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>m12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>m20</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>m21</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>m22</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bidirectional serialize/deserialize an orthogonal matrix by creating a quaternion, and writing 3 components of the quaternion in 2 bytes each. 
<p>
Use 6 bytes instead of 36 Lossy, although the result is renormalized <dl class="return" compact><dt><b>Returns:</b></dt><dd>true on success, false on failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="62e28b643291d050ca0984b432753e8f"></a><!-- doxytag: member="RakNet::BitStream::SerializeVector" ref="62e28b643291d050ca0984b432753e8f" args="(bool writeToBitstream, templateType &amp;x, templateType &amp;y, templateType &amp;z)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool RakNet::BitStream::SerializeVector           </td>
          <td>(</td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>writeToBitstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Bidirectional serialize/deserialize a vector, using 10 bytes instead of 12. 
<p>
Loses accuracy to about 3/10ths and only saves 2 bytes, so only use if accuracy is not important. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>writeToBitstream</em>&nbsp;</td><td>true to write from your data to this bitstream. False to read from this bitstream and write to your data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>x</em>&nbsp;</td><td>x </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>y</em>&nbsp;</td><td>y </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>z</em>&nbsp;</td><td>z </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>true if <em>writeToBitstream</em> is true. true if <em>writeToBitstream</em> is false and the read was successful. false if <em>writeToBitstream</em> is false and the read was not successful. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a56ebc6a1381369ddc2a6d7821512d7e"></a><!-- doxytag: member="RakNet::BitStream::SetWriteOffset" ref="a56ebc6a1381369ddc2a6d7821512d7e" args="(const BitSize_t offset)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::SetWriteOffset           </td>
          <td>(</td>
          <td class="paramtype">const BitSize_t&nbsp;</td>
          <td class="paramname"> <em>offset</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Move the write pointer to a position on the array. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>offset</em>&nbsp;</td><td>the offset from the start of the array. </td></tr>
  </table>
</dl>
<dl class="attention" compact><dt><b>Attention:</b></dt><dd>Dangerous if you don't know what you are doing! For efficiency reasons you can only write mid-stream if your data is byte aligned. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7b2969415bef76788596fecc3d9505ab"></a><!-- doxytag: member="RakNet::BitStream::Write" ref="7b2969415bef76788596fecc3d9505ab" args="(const RakString &amp;inTemplateVar)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::Write           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRakNet_1_1RakString.html">RakString</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inTemplateVar</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write a string to a bitstream. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>var</em>&nbsp;</td><td>The value to write </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="94d26ac0f6bb22f975ad346f2a309e74"></a><!-- doxytag: member="RakNet::BitStream::Write" ref="94d26ac0f6bb22f975ad346f2a309e74" args="(const SystemAddress &amp;inTemplateVar)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::Write           </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRakNet_1_1SystemAddress.html">SystemAddress</a> &amp;&nbsp;</td>
          <td class="paramname"> <em>inTemplateVar</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write a systemAddress to a bitstream. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inTemplateVar</em>&nbsp;</td><td>The value to write </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="3124e2e59123caf4b383ee5092621775"></a><!-- doxytag: member="RakNet::BitStream::Write" ref="3124e2e59123caf4b383ee5092621775" args="(const bool &amp;inTemplateVar)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::Write           </td>
          <td>(</td>
          <td class="paramtype">const bool &amp;&nbsp;</td>
          <td class="paramname"> <em>inTemplateVar</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write a bool to a bitstream. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inTemplateVar</em>&nbsp;</td><td>The value to write </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="26624b5669df1c38f6dd6dabf4c1b769"></a><!-- doxytag: member="RakNet::BitStream::Write" ref="26624b5669df1c38f6dd6dabf4c1b769" args="(BitStream *bitStream, BitSize_t numberOfBits)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::Write           </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRakNet_1_1BitStream.html">BitStream</a> *&nbsp;</td>
          <td class="paramname"> <em>bitStream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BitSize_t&nbsp;</td>
          <td class="paramname"> <em>numberOfBits</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write one bitstream to another. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numberOfBits</em>&nbsp;</td><td>bits to write </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bitStream</em>&nbsp;</td><td>the bitstream to copy from </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="0c6e2624a5960f9ac40d4072a6e607e5"></a><!-- doxytag: member="RakNet::BitStream::Write" ref="0c6e2624a5960f9ac40d4072a6e607e5" args="(const char *inputByteArray, const unsigned int numberOfBytes)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::Write           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>inputByteArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&nbsp;</td>
          <td class="paramname"> <em>numberOfBytes</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write an array or casted stream or raw data. This does NOT do endian swapping. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inputByteArray</em>&nbsp;</td><td>a byte buffer </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numberOfBytes</em>&nbsp;</td><td>the size of <em>input</em> in bytes </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="260675ffb5cb824cbed3465b0319383c"></a><!-- doxytag: member="RakNet::BitStream::Write" ref="260675ffb5cb824cbed3465b0319383c" args="(const templateType &amp;inTemplateVar)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::Write           </td>
          <td>(</td>
          <td class="paramtype">const templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>inTemplateVar</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write any integral type to a bitstream. 
<p>
Undefine __BITSTREAM_NATIVE_END if you need endian swapping. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inTemplateVar</em>&nbsp;</td><td>The value to write </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bcd8b1c73408fc1e4e8088ca858c0f7a"></a><!-- doxytag: member="RakNet::BitStream::WriteAlignedBytes" ref="bcd8b1c73408fc1e4e8088ca858c0f7a" args="(const unsigned char *inByteArray, const unsigned int numberOfBytesToWrite)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::WriteAlignedBytes           </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>inByteArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&nbsp;</td>
          <td class="paramname"> <em>numberOfBytesToWrite</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Align the bitstream to the byte boundary and then write the specified number of bits. 
<p>
This is faster than WriteBits but wastes the bits to do the alignment and requires you to call ReadAlignedBits at the corresponding read position. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inByteArray</em>&nbsp;</td><td>The data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numberOfBytesToWrite</em>&nbsp;</td><td>The size of input. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="2ae285a7aaba6f50b5ce8e5bf4163639"></a><!-- doxytag: member="RakNet::BitStream::WriteAlignedBytesSafe" ref="2ae285a7aaba6f50b5ce8e5bf4163639" args="(const char *inByteArray, const unsigned int inputLength, const unsigned int maxBytesToWrite)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::WriteAlignedBytesSafe           </td>
          <td>(</td>
          <td class="paramtype">const char *&nbsp;</td>
          <td class="paramname"> <em>inByteArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&nbsp;</td>
          <td class="paramname"> <em>inputLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned int&nbsp;</td>
          <td class="paramname"> <em>maxBytesToWrite</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Aligns the bitstream, writes inputLength, and writes input. Won't write beyond maxBytesToWrite. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inByteArray</em>&nbsp;</td><td>The data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inputLength</em>&nbsp;</td><td>The size of input. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maxBytesToWrite</em>&nbsp;</td><td>Max bytes to write </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="6357c08afed23e2e857c418cbbb3a29a"></a><!-- doxytag: member="RakNet::BitStream::WriteBits" ref="6357c08afed23e2e857c418cbbb3a29a" args="(const unsigned char *inByteArray, BitSize_t numberOfBitsToWrite, const bool rightAlignedBits=true)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::WriteBits           </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&nbsp;</td>
          <td class="paramname"> <em>inByteArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BitSize_t&nbsp;</td>
          <td class="paramname"> <em>numberOfBitsToWrite</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&nbsp;</td>
          <td class="paramname"> <em>rightAlignedBits</em> = <code>true</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write numberToWrite bits from the input source. 
<p>
Right aligned data means in the case of a partial byte, the bits are aligned from the right (bit 0) rather than the left (as in the normal internal representation) You would set this to true when writing user data, and false when copying bitstream data, such as writing one bitstream to another. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inByteArray</em>&nbsp;</td><td>The data </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>numberOfBitsToWrite</em>&nbsp;</td><td>The number of bits to write </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>rightAlignedBits</em>&nbsp;</td><td>if true data will be right aligned </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="d64fbada82c7df3f8a191b13a27d0027"></a><!-- doxytag: member="RakNet::BitStream::WriteBitsFromIntegerRange" ref="d64fbada82c7df3f8a191b13a27d0027" args="(const templateType value, const templateType minimum, const templateType maximum, const int requiredBits, bool allowOutsideRange=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::WriteBitsFromIntegerRange           </td>
          <td>(</td>
          <td class="paramtype">const templateType&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const templateType&nbsp;</td>
          <td class="paramname"> <em>minimum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const templateType&nbsp;</td>
          <td class="paramname"> <em>maximum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&nbsp;</td>
          <td class="paramname"> <em>requiredBits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>allowOutsideRange</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>requiredBits</em>&nbsp;</td><td>Primarily for internal use, called from above function() after calculating number of bits needed to represent maximum-minimum </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="c28f6c4fb26bedc0858ed478961c2dc1"></a><!-- doxytag: member="RakNet::BitStream::WriteBitsFromIntegerRange" ref="c28f6c4fb26bedc0858ed478961c2dc1" args="(const templateType value, const templateType minimum, const templateType maximum, bool allowOutsideRange=false)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::WriteBitsFromIntegerRange           </td>
          <td>(</td>
          <td class="paramtype">const templateType&nbsp;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const templateType&nbsp;</td>
          <td class="paramname"> <em>minimum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const templateType&nbsp;</td>
          <td class="paramname"> <em>maximum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&nbsp;</td>
          <td class="paramname"> <em>allowOutsideRange</em> = <code>false</code></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Given the minimum and maximum values for an integer type, figure out the minimum number of bits to represent the range Then write only those bits <dl class="note" compact><dt><b>Note:</b></dt><dd>A static is used so that the required number of bits for (maximum-minimum) is only calculated once. This does require that <em>minimum</em> and  are fixed values for a given line of code for the life of the program </dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>Integer value to write, which should be between <em>minimum</em> and <em>maximum</em> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>minimum</em>&nbsp;</td><td>Minimum value of <em>value</em> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>maximum</em>&nbsp;</td><td>Maximum value of <em>value</em> </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>allowOutsideRange</em>&nbsp;</td><td>If true, all sends will take an extra bit, however value can deviate from outside <em>minimum</em> and <em>maximum</em>. If false, will assert if the value deviates. This should match the corresponding value passed to <a class="el" href="classRakNet_1_1BitStream.html#45c9d2484823bb62430ded4d7eeda201" title="Read any integral type from a bitstream.">Read()</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9f99f5796c7124daebc5d71776dd641d"></a><!-- doxytag: member="RakNet::BitStream::WriteCasted" ref="9f99f5796c7124daebc5d71776dd641d" args="(const sourceType &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class destinationType , class sourceType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::WriteCasted           </td>
          <td>(</td>
          <td class="paramtype">const sourceType &amp;&nbsp;</td>
          <td class="paramname"> <em>value</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write one type serialized as another (smaller) type, to save bandwidth serializationType should be uint8_t, uint16_t, uint24_t, or uint32_t Example: int num=53; WriteCasted&lt;uint8_t&gt;(num); would use 1 byte to write what would otherwise be an integer (4 or 8 bytes) <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>value</em>&nbsp;</td><td>The value to write </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="f2a9f9515ed4783e832e5822942003a8"></a><!-- doxytag: member="RakNet::BitStream::WriteCompressed" ref="f2a9f9515ed4783e832e5822942003a8" args="(const templateType &amp;inTemplateVar)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::WriteCompressed           </td>
          <td>(</td>
          <td class="paramtype">const templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>inTemplateVar</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write any integral type to a bitstream. 
<p>
Undefine __BITSTREAM_NATIVE_END if you need endian swapping. If you are not using __BITSTREAM_NATIVE_END the opposite is true for types larger than 1 byte For floating point, this is lossy, using 2 bytes for a float and 4 for a double. The range must be between -1 and +1. For non-floating point, this is lossless, but only has benefit if you use less than half the bits of the type <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inTemplateVar</em>&nbsp;</td><td>The value to write</td></tr>
  </table>
</dl>
Undefine __BITSTREAM_NATIVE_END if you need endian swapping. For floating point, this is lossy, using 2 bytes for a float and 4 for a double. The range must be between -1 and +1. For non-floating point, this is lossless, but only has benefit if you use less than half the bits of the type If you are not using __BITSTREAM_NATIVE_END the opposite is true for types larger than 1 byte <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inTemplateVar</em>&nbsp;</td><td>The value to write </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="06e2877d7238d9675714eee221a144dd"></a><!-- doxytag: member="RakNet::BitStream::WriteCompressedDelta" ref="06e2877d7238d9675714eee221a144dd" args="(const bool &amp;currentValue, const bool &amp;lastValue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::WriteCompressedDelta           </td>
          <td>(</td>
          <td class="paramtype">const bool &amp;&nbsp;</td>
          <td class="paramname"> <em>currentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&nbsp;</td>
          <td class="paramname"> <em>lastValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write a bool delta. Same thing as just calling Write. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>currentValue</em>&nbsp;</td><td>The current value to write </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lastValue</em>&nbsp;</td><td>The last value to compare against </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="202c4a2557df531aca0cfabcbe956dfe"></a><!-- doxytag: member="RakNet::BitStream::WriteCompressedDelta" ref="202c4a2557df531aca0cfabcbe956dfe" args="(const templateType &amp;currentValue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::WriteCompressedDelta           </td>
          <td>(</td>
          <td class="paramtype">const templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>currentValue</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Save as <a class="el" href="classRakNet_1_1BitStream.html#6de88ae0698472b2fdd968c95bc478fb" title="Write any integral type to a bitstream.">WriteCompressedDelta(const templateType &amp;currentValue, const templateType &amp;lastValue)</a> when we have an unknown second parameter. 
<p>
Save as <a class="el" href="classRakNet_1_1BitStream.html#6de88ae0698472b2fdd968c95bc478fb" title="Write any integral type to a bitstream.">WriteCompressedDelta(const templateType &amp;currentValue, const templateType &amp;lastValue)</a> when we have an unknown second parameter. 
</div>
</div><p>
<a class="anchor" name="6de88ae0698472b2fdd968c95bc478fb"></a><!-- doxytag: member="RakNet::BitStream::WriteCompressedDelta" ref="6de88ae0698472b2fdd968c95bc478fb" args="(const templateType &amp;currentValue, const templateType &amp;lastValue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::WriteCompressedDelta           </td>
          <td>(</td>
          <td class="paramtype">const templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>currentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>lastValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write any integral type to a bitstream. 
<p>
If the current value is different from the last value the current value will be written. Otherwise, a single bit will be written For floating point, this is lossy, using 2 bytes for a float and 4 for a double. The range must be between -1 and +1. For non-floating point, this is lossless, but only has benefit if you use less than half the bits of the type If you are not using __BITSTREAM_NATIVE_END the opposite is true for types larger than 1 byte <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>currentValue</em>&nbsp;</td><td>The current value to write </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lastValue</em>&nbsp;</td><td>The last value to compare against</td></tr>
  </table>
</dl>
If the current value is different from the last value the current value will be written. Otherwise, a single bit will be written For floating point, this is lossy, using 2 bytes for a float and 4 for a double. The range must be between -1 and +1. For non-floating point, this is lossless, but only has benefit if you use less than half the bits of the type If you are not using __BITSTREAM_NATIVE_END the opposite is true for types larger than 1 byte <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>currentValue</em>&nbsp;</td><td>The current value to write </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lastValue</em>&nbsp;</td><td>The last value to compare against </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="623543a19e73e94558a5bcae4435146d"></a><!-- doxytag: member="RakNet::BitStream::WriteDelta" ref="623543a19e73e94558a5bcae4435146d" args="(const bool &amp;currentValue, const bool &amp;lastValue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::WriteDelta           </td>
          <td>(</td>
          <td class="paramtype">const bool &amp;&nbsp;</td>
          <td class="paramname"> <em>currentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool &amp;&nbsp;</td>
          <td class="paramname"> <em>lastValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write a bool delta. Same thing as just calling Write. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>currentValue</em>&nbsp;</td><td>The current value to write </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lastValue</em>&nbsp;</td><td>The last value to compare against </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="ab257336c9c88be2b3cdbfcfa1d58959"></a><!-- doxytag: member="RakNet::BitStream::WriteDelta" ref="ab257336c9c88be2b3cdbfcfa1d58959" args="(const templateType &amp;currentValue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::WriteDelta           </td>
          <td>(</td>
          <td class="paramtype">const templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>currentValue</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
WriteDelta when you don't know what the last value is, or there is no last value. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>currentValue</em>&nbsp;</td><td>The current value to write </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="9b68a7467d37b6f4a46e29de8dec6fec"></a><!-- doxytag: member="RakNet::BitStream::WriteDelta" ref="9b68a7467d37b6f4a46e29de8dec6fec" args="(const templateType &amp;currentValue, const templateType &amp;lastValue)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::WriteDelta           </td>
          <td>(</td>
          <td class="paramtype">const templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>currentValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const templateType &amp;&nbsp;</td>
          <td class="paramname"> <em>lastValue</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write any integral type to a bitstream. 
<p>
If the current value is different from the last value the current value will be written. Otherwise, a single bit will be written <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>currentValue</em>&nbsp;</td><td>The current value to write </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lastValue</em>&nbsp;</td><td>The last value to compare against</td></tr>
  </table>
</dl>
If the current value is different from the last value the current value will be written. Otherwise, a single bit will be written <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>currentValue</em>&nbsp;</td><td>The current value to write </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lastValue</em>&nbsp;</td><td>The last value to compare against </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="8b37ff9ba34ce6f98c8521710ba51366"></a><!-- doxytag: member="RakNet::BitStream::WriteFloat16" ref="8b37ff9ba34ce6f98c8521710ba51366" args="(float x, float floatMin, float floatMax)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::WriteFloat16           </td>
          <td>(</td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>floatMin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&nbsp;</td>
          <td class="paramname"> <em>floatMax</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write a float into 2 bytes, spanning the range between <em>floatMin</em> and <em>floatMax</em>. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>x</em>&nbsp;</td><td>The float to write </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>floatMin</em>&nbsp;</td><td>Predetermined minimum value of f </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>floatMax</em>&nbsp;</td><td>Predetermined maximum value of f </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="32d45047ed2c0904d4a4ce389c0cef97"></a><!-- doxytag: member="RakNet::BitStream::WriteNormQuat" ref="32d45047ed2c0904d4a4ce389c0cef97" args="(templateType w, templateType x, templateType y, templateType z)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::WriteNormQuat           </td>
          <td>(</td>
          <td class="paramtype">templateType&nbsp;</td>
          <td class="paramname"> <em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write a normalized quaternion in 6 bytes + 4 bits instead of 16 bytes. Slightly lossy. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>w</em>&nbsp;</td><td>w </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>x</em>&nbsp;</td><td>x </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>y</em>&nbsp;</td><td>y </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>z</em>&nbsp;</td><td>z </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="95cfc5e892e308e6cda4738d6001ee61"></a><!-- doxytag: member="RakNet::BitStream::WriteNormVector" ref="95cfc5e892e308e6cda4738d6001ee61" args="(templateType x, templateType y, templateType z)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::WriteNormVector           </td>
          <td>(</td>
          <td class="paramtype">templateType&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write a normalized 3D vector, using (at most) 4 bytes + 3 bits instead of 12-24 bytes. 
<p>
Will further compress y or z axis aligned vectors. Accurate to 1/32767.5. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>x</em>&nbsp;</td><td>x </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>y</em>&nbsp;</td><td>y </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>z</em>&nbsp;</td><td>z </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="73c6f4399d99c74d379d0f12448bf7e3"></a><!-- doxytag: member="RakNet::BitStream::WriteOrthMatrix" ref="73c6f4399d99c74d379d0f12448bf7e3" args="(templateType m00, templateType m01, templateType m02, templateType m10, templateType m11, templateType m12, templateType m20, templateType m21, templateType m22)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::WriteOrthMatrix           </td>
          <td>(</td>
          <td class="paramtype">templateType&nbsp;</td>
          <td class="paramname"> <em>m00</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType&nbsp;</td>
          <td class="paramname"> <em>m01</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType&nbsp;</td>
          <td class="paramname"> <em>m02</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType&nbsp;</td>
          <td class="paramname"> <em>m10</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType&nbsp;</td>
          <td class="paramname"> <em>m11</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType&nbsp;</td>
          <td class="paramname"> <em>m12</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType&nbsp;</td>
          <td class="paramname"> <em>m20</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType&nbsp;</td>
          <td class="paramname"> <em>m21</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType&nbsp;</td>
          <td class="paramname"> <em>m22</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write an orthogonal matrix by creating a quaternion, and writing 3 components of the quaternion in 2 bytes each. 
<p>
Use 6 bytes instead of 36 Lossy, although the result is renormalized 
</div>
</div><p>
<a class="anchor" name="9e537be47615fc625f47f7f99f3955fb"></a><!-- doxytag: member="RakNet::BitStream::WritePtr" ref="9e537be47615fc625f47f7f99f3955fb" args="(templateType *inTemplateVar)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::WritePtr           </td>
          <td>(</td>
          <td class="paramtype">templateType *&nbsp;</td>
          <td class="paramname"> <em>inTemplateVar</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write the dereferenced pointer to any integral type to a bitstream. 
<p>
Undefine __BITSTREAM_NATIVE_END if you need endian swapping. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>inTemplateVar</em>&nbsp;</td><td>The value to write </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="92da13ea0b4bdf7676a8df2e2d0c68b7"></a><!-- doxytag: member="RakNet::BitStream::WriteVector" ref="92da13ea0b4bdf7676a8df2e2d0c68b7" args="(templateType x, templateType y, templateType z)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class templateType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void RakNet::BitStream::WriteVector           </td>
          <td>(</td>
          <td class="paramtype">templateType&nbsp;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType&nbsp;</td>
          <td class="paramname"> <em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">templateType&nbsp;</td>
          <td class="paramname"> <em>z</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Write a vector, using 10 bytes instead of 12. 
<p>
Loses accuracy to about 3/10ths and only saves 2 bytes, so only use if accuracy is not important. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>x</em>&nbsp;</td><td>x </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>y</em>&nbsp;</td><td>y </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>z</em>&nbsp;</td><td>z </td></tr>
  </table>
</dl>

</div>
</div><p>
<hr>The documentation for this class was generated from the following file:<ul>
<li>d:/temp/RakNet_PC/Source/<a class="el" href="BitStream_8h.html">BitStream.h</a></ul>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Feb 1 13:33:47 2012 for RakNet by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.7.1 </small></address>
</body>
</html>
