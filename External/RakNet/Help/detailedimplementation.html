<HTML>
<HEAD>

<TITLE>Detailed Implementation</TITLE>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"></HEAD>
<link href="RaknetManual.css" rel="stylesheet" type="text/css">
<meta name="title" content="RakNet - Advanced multiplayer game networking API">
</HEAD>
<BODY BGCOLOR="#ffffff" LINK="#003399" vlink="#003399" alink="#003399" LEFTMARGIN="0" TOPMARGIN="0" MARGINWIDTH="0" MARGINHEIGHT="0"">
<img src="RakNet_Icon_Final-copy.jpg" alt="Jenkins Software" width="150" height="150"><BR>
<BR>

<table width="100%" border="0"><tr><td bgcolor="#2c5d92" class="RakNetWhiteHeader">
<img src="spacer.gif" width="8" height="1">Detailed Implementation</td>
</tr></table>
<table width="100%" border="0" cellspacing="0" cellpadding="10">
  <tr>
    <td>Implementation <BR>
      <BR>
To implement RakNet all you have to do is get an instance of RakPeer in your program.<BR>
<BR>
These are the most common headers you'll need:</td>
  </tr>
</table>
<table width="100%" border="0">
  <tr>
    <td bgcolor="#2c5d92" class="RakNetWhiteHeader"><img src="spacer.gif" width="8" height="1">Headers</td>
  </tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="10">
  <tr>
    <td class="RakNetManualTextBody">#include "MessageIdentifiers.h"<BR>
#include "RakPeerInterface.h"<BR>
#include "RakNetTypes.h"<BR>
<BR>
MessageIdentifiers.h contains a giant enumeration representing the native message identifiers that RakNet uses to send you messages, such as disconnection notifications.  Since you will probably want to define your own message identifiers, your enumerations should start at the 
        highest enumeration in MessageIdentifiers.h + 1<font color="#666666" size="2" face="Geneva, Verdana, Arial, Helvetica, sans-serif">. RakNetworkFactory.h is an implementation of the factory design pattern, used to get a pointer to RakPeerInterface.  This is necessary to use the DLL.  RakPeerInterface.h is an interface for the RakPeer 
    class. RakNetTypes.h defines the structures used in RakNet, including <I>SystemAddress</I> - a unique identifier for systems, and <I>Packet</I> which the API returns to you when you get data or when it needs to send you a message.</td>
  </tr>
</table>
<table width="100%" border="0">
  <tr>
    <td bgcolor="#2c5d92" class="RakNetWhiteHeader"><img src="spacer.gif" width="8" height="1">Instancing</td>
  </tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="10">
  <tr>
    <td class="RakNetManualTextBody"><BR>
RakNet::RakPeerInterface* peer = RakNet::RakPeerInterface::GetInstance();<BR>
<BR>
That code would give you one instance of  the peer.  Usually you would only want one of these in a particular exe.<BR>
<BR>
The next step is to connect, either as client or as a server.<BR>
<BR>
For example:<BR></td>
  </tr>
</table>
<table width="100%" border="0">
  <tr>
    <td bgcolor="#2c5d92" class="RakNetWhiteHeader"><img src="spacer.gif" width="8" height="1">Connection as Client </td>
  </tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="10">
  <tr>
    <td class="RakNetManualTextBody">peer->Startup(1,  &SocketDescriptor(), 1)<BR>
peer
    ->Connect(serverIP, serverPort, 0, 0);<BR>
    <BR>
The call to Startup starts the network threads.<br>
The first parameter is the maximum mumber of connections. For a pure client, we use 1.<br>
The second parameter (set to 30 in this example) is the thread sleep timer.  A value of 0 is good for games that need fast responses, such as a shooter.  Otherwise, a value of 30 will give good response times and will require very little CPU usage.<br>
The third parameter (SocketDescriptor()), specifies the ports/addresses to listen on . Since we want a client, we don't need to specify anything.<BR>
<br>
The call to Connect connects to the server.<br>
The first parameter, serverIP, is the IP address or domain of the server.  If you want to connect to your own system, such as when running two copies of the same program, use "127.0.0.1" or "localhost" which is accepted notation for your own system.  For IPV6, this is &quot;::1&quot;.<BR>
The next  parameter in Connect is the serverPort.  This is the port you want to try to connect to on the server.  If you specify a port the server is not expecting data on you won't be able to connect just like if you had entered the wrong IP.  The IP and the port always work together in this fashion to form the complete address.  How do you know what port to connect to?  Well as the programmer you decide this ahead of time and then just hardcode it into your program.  How do you choose a port?  You can choose whatever you want as long as no one else is using it and its within the range of 2^16 (0 to 65535).  However, certain ports are reserved for use by established programs, such as your web browser, telnet, and FTP.  You can look up these port assignments on the internet, but the quick and dirty answer is most ports under 32000 are reserved and ports over 32000 are open to whoever wants them.<BR>
<BR>
In practice ports are generally set with #define per program and not changed.  For example:<BR>
<BR>
#define SERVER_PORT 60005<BR>
#define CLIENT_PORT 60006<BR>
<BR>
This way the server will always know what port to respond to and the clients will always know what port to connect to.  It also saves end-users the trouble of typing the ports in.<BR>
<BR>
Note that connection attempts are asynchronous.  The function will return CONNECTION_ATTEMPT_STARTED immediately if it succeeded in the attempt to connect, but it does not mean your connection succeeded. You know your connection succeeded when you call RakPeerInterface::Receive() and a Packet is returned with the first byte ID_CONNECTION_ACCEPTED.<br>
You get a network message ID_CONNECTION_ATTEMPT_FAILED when the connection fails.<br>
RakNet connects quickly so if you don't connect within a few seconds it's not going to connect. ID_CONNECTION_ATTEMPT_FAILED will be returned to inform you of this.<BR>
<BR>
Starting as a server is similar.</td>
  </tr>
</table>
<table width="100%" border="0">
  <tr>
    <td bgcolor="#2c5d92" class="RakNetWhiteHeader"><img src="spacer.gif" width="8" height="1">Connection as Server </td>
  </tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="10">
  <tr>
    <td class="RakNetManualTextBody"><p>peer->Startup(maxConnectionsAllowed, &SocketDescriptor(serverPort,0), 1);<br>
      peer->SetMaximumIncomingConnections(maxPlayersPerServer); </p>
      <p>The first parameter to Startup is how many simultaneous client connections to allow. The second and third parameter tells what port to listen on.<br>
        The call to SetMaximumIncomingConnections sets how many incoming connections are allowed.<BR>
        Keep in mind that the actual number of players you could have playing is one more than the number of clients you support if you program your game to allow the server to act as a player.  If your server is a dedicated server or if you program your game to have both a client and a server on the same system (not recommended) then obviously the number of people who could play would change accordingly.<BR>
  <BR>
      </p></td>
  </tr>
</table>
<table width="100%" border="0">
  <tr>
    <td bgcolor="#2c5d92" class="RakNetWhiteHeader"><img src="spacer.gif" width="8" height="1">Peer to peer connections </td>
  </tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="10">
  <tr>
    <td class="RakNetManualTextBody">RakNet::SocketDescriptor sd(60000,0);<br>
      peer->Startup(10,  &amp;sd, 1);<BR>
peer->SetMaximumIncomingConnections(4);<BR>
<BR>
Startup sets 10 allowable connections.  An allowable connection is either incoming or outgoing.  It uses port 60000 to receive data.<br>
SetMaximumIncomingConnections is necessary if you want to allow other peers to connect to you, but is not necessary if you only plan to connect to others.  In this case, it sets the value to 4.  This is a maximum value rather than a reserved value, so it is still possible to say connect to 8 peers - you would then only be able to accept 2 incoming connections until you disconnected from one or more of those peers.</td>
  </tr>
</table>
<table width="100%" border="0">
  <tr>
    <td bgcolor="#2c5d92" class="RakNetWhiteHeader"><img src="spacer.gif" width="8" height="1">Reading Packets </td>
  </tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="10">
  <tr>
    <td class="RakNetManualTextBody"><p><span class="RakNetCode">RakNet::Packet *packet = peer->Receive();</span><BR>
      <BR>
      It's that easy.  If packet is 0 then there was nothing to read and you can go on with your game.  Otherwise you got some data. You should normally call this in a loop, for example:</p>
      <p><span class="RakNetCode">RakNet::Packet *packet;<br>
        for (packet=peer-&gt;Receive(); packet; peer-&gt;DeallocatePacket(packet), packet=peer-&gt;Receive()) {<br>
        }
        </span><BR>
        <BR>
        You can get two kinds of data:<BR>
        Messages from the engine<BR>
        Messages from other instances of RakNet, on the same computer or from other computers<BR>
        Both are handled the same way.<BR>
        <BR>
      Lets look at the Packet struct:</p>
      <p class="RakNetCode">nam<span class="RakNetCode">espace RakNet<br>
        {<BR>
      </span>struct Packet<br>
        {<br>
        /// The system that send this packet.<br>
      SystemAddress systemAddress;<br>
/// A unique identifier for the system that sent this packet, regardless of IP address (internal / external / remote system)<br>
        /// Only valid once a connection has been established (ID_CONNECTION_REQUEST_ACCEPTED, or ID_NEW_INCOMING_CONNECTION)<br>
        /// Until that time, will be UNASSIGNED_RAKNET_GUID<br>
      RakNetGUID guid;<br>
/// The length of the data in bytes<br>
      unsigned int length;<br>
/// The length of the data in bits<br>
      BitSize_t bitSize;<br>
/// The data from the sender<br>
      unsigned char* data;<br>
      } // Namespace</p>
      <p>        systemAddress specifies the origin of the packet. Every connected system has a unique SystemAddress which is assigned automatically. Note that the system address will be constant over the lifetime of the connection.  Certain native network messages use the systemAddress member- for example ID_REMOTE_DISCONNECTION_NOTIFICATION tells you as a client that another client has disconnected.  systemAddress in that case specifies which client.  UNASSIGNED_SYSTEM_ADDRESS is a reserved value for "Unknown". You should not use systemAddress as a unique identifier for a remote computer. This is because the same computer can have a different systemAddress to every other connection. Use RakNetGUID as a unique identifier for a particular instance of RakPeerInterface.<BR>
        <BR>
        bitSize tells you how many bits long the data field of the struct is.<BR>
        <BR>
        Now that you got a packet you need to determine what the data means.  Usually the first byte of the data is an enum that specifies type (see creating packets for more information).  This is not always the case as you'll later learn, because with some packets, you might get a TimeStamp. To make things easy here it is a function to get the identifier when the packet has a TimeStamp:<BR>
        <BR>
        <span class="RakNetCode">unsigned char GetPacketIdentifier(Packet *p)<BR>
        {<BR>
        if ((unsigned char)p->data[0] == ID_TIMESTAMP)<BR>
        return (unsigned char) p->data[sizeof(MessageID) + sizeof(RakNet::Time)];<BR>
        else<BR>
        return (unsigned char) p->data[0];<BR>
        }<BR>
        </span><BR>
        This will return an unsigned char, which corresponds to an enum specified in MessageIdentifiers.h.<BR>
        <BR>
        The network engine will return certain messages only for the client, certain messages only for the server, and certain messages for both.  For a full explanation of the messages refer to MessageIdentifiers.h.  The important ones to worry about are ID_NEW_INCOMING_CONNECTION and ID_CONNECTION_REQUEST_ACCEPTED.  These mean that the server or a peer got a new incoming client, and the client or a peer has successfully connected respectively.  At this point you can send your own messages. <BR>
        <BR>
        If the packet identifier is NOT one of the pre-defined identifiers then you got user data which was sent by another system.  You can then decode the data and handle it in your game as appropriate.  See <A HREF="creatingpackets.html">creating packets</A> for information on encoding and decoding data.<BR>
        <BR>
        <I>IMPORTANT!</I><BR>
        When you are done with your data, don't forget to deallocate the packet!  Just pass it to DeallocatePacket.<br>
        <BR>
    peer->DeallocatePacket(p);</p></td>
  </tr>
</table>
<table width="100%" border="0">
  <tr>
    <td bgcolor="#2c5d92" class="RakNetWhiteHeader"><img src="spacer.gif" width="8" height="1">Sending Data </td>
  </tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="10">
  <tr>
    <td class="RakNetManualTextBody"><p>The best way to illustrate sending data is with an example:<BR>
      const char* message = "Hello World";<BR>
  <BR>
      To all connected systems:<BR>
      peer->Send((char*)message, strlen(message)+1, HIGH_PRIORITY, RELIABLE, 0, UNASSIGNED_RAKNET_GUID, true);<BR>
  <BR>
      The first parameter is your data and must be a byte stream.  Since we're sending a string, and a string is a byte stream, we can send it directly without any casting.<BR>
  <BR>
      The second parameter is how many bytes to send.  In this example we send the length of the string and one more for the null terminator.<BR>
  <BR>
      The third  parameter is the priority of the packet.  This takes one of three values:<BR>
      IMMEDIATE_PRIORITY,<br>
      HIGH_PRIORITY<BR>
      MEDIUM_PRIORITY<BR>
      LOW_PRIORITY<BR>
  <BR>
      IMMEDIATE_PRIORITY messages signal RakNet's update thread to update immediately. Assuming bandwidth is available, they get sent immediately. HIGH_PRIORITY, MEDIUM_PRIORITY, and LOW_PRIORITY messages are put into a buffer. The next time RakNet's update thread ticks (which is every 10 milliseconds) those messages get sent. Those 3 priorities can be more efficient for bandwidth, because if multiple messages can be aggregated into a single datagram, RakNet will transparently do so</p>
      <p>Twice as many messages get sent out for each higher priority.  So if messages of all priorities were waiting to go out, 8 IMMEDIATE_PRIORITY, 4 HIGH_PRIORITY, 2 MEDIUM_PRIORITY, and 1 LOW_PRIORITY would be sent. Obviously however, if only LOW_PRIORITY messages were waiting at all, then those messages would all go out as fast as possible.<BR>
        <BR>
        The fourth  parameter takes one of five major values.  Lets say you send data 1,2,3,4,5,6.  Here's the order and substance of what you might get back:<BR>
        <BR>
        UNRELIABLE - 5, 1, 6<BR>
        UNRELIABLE_SEQUENCED - 5 (6 was lost in transit, 1,2,3,4 arrived later than 5)<BR>
        RELIABLE - 5, 1, 4, 6, 2, 3<BR>
        RELIABLE_ORDERED - 1, 2, 3, 4, 5, 6<BR>
        RELIABLE_SEQUENCED - 5, 6 (1,2,3,4 arrived later than 5)<BR>
        <BR>
        For more details on this refer to PacketPriority.h.<BR>
        <BR>
      The fifth parameter to Send() (0 in this example) is which ordering stream to use.  This is used for relative ordering of packets in relation to other packets on the same stream.  It's not important for now, but for more information on this refer to the <A HREF="sendingpackets.html">Sending Packets</A> section.</p>
    <p>The sixth parameter (UNASSIGNED_RAKNET_GUID), is the remote system to send to. UNASSIGNED_RAKNET_GUID is a reserved value meaning &quot;no-one in particular&quot;. This parameter means one of two things : either who you want to send the packet to, or who you don't want to send the packet to, depending on the value of broadcast, which is the last parameter.<br>
          <BR>
    The seventh parameter (true in this example) is whether to broadcast to all connected systems or not.  This parameter works with the sixth parameter.  If broadcast is true, then the sixth parameter specifies who not to send to.  If it is false, then it specifies who to send to.  If we want to broadcast to everyone, then we just specify UNASSIGNED_RAKNET_GUID.  This works out when relaying packets, because the Packet::systemAddress field in the packet you get will specify who the sender is.   We can relay the packet to everyone BUT the sender, which makes sense since we usually don't want to send the same information back to the person who just sent it to us.</p></td>
  </tr>
</table>
<table width="100%" border="0">
  <tr>
    <td bgcolor="#2c5d92" class="RakNetWhiteHeader"><img src="spacer.gif" width="8" height="1">Shutting Down </td>
  </tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="10">
  <tr>
    <td class="RakNetManualTextBody"><BR>
Shutting down is easy and nearly instantaneous.  Just call Shutdown() on your peer object, and then destroy it <BR>
<BR>
somePeer->Shutdown(300);<br>
<BR>
Shutdown stops the network threads. If you specify a higher than 0 parameter to Shutdown(), Shutdown() will block for up to this amount of time to notify connected systems (if any) to inform them of the connection dropping. 0 will cause a slient Shutdown(), and remote systems will detect the disconnection within about 10 seconds, returning ID_CONNECTION_LOST.</td>
  </tr>
</table>
<table width="100%" border="0">
  <tr>
    <td bgcolor="#2c5d92" class="RakNetWhiteHeader"><img src="spacer.gif" width="8" height="1">Cleaning Up </td>
  </tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="10">
  <tr>
    <td>Just pass the instance that the factory gave you to the DestroyRakPeerInterface.  You may want to do this mid-program to free memory but it is not required.<BR>
      <BR>
RakNet::RakPeerInterface::DestroyInstance(rakPeer);</td>
  </tr>
</table>
<table width="100%" border="0">
  <tr>
    <td bgcolor="#2c5d92" class="RakNetWhiteHeader"><img src="spacer.gif" width="8" height="1">See Also </td>
  </tr>
</table>
<table width="100%" border="0" cellspacing="0" cellpadding="10">
  <tr>
    <td><p><BR>
    Next page: <A HREF="tutorial.html">Step by step tutorial</A></p>
    <p><A HREF="index.html">Index</A><BR>
      <A HREF="introduction.html">Introduction</A><BR>
      <A HREF="systemoverview.html">System Overview</A><BR>
      <A HREF="tutorial.html">Tutorial</A><BR>
      <A HREF="compilersetup.html">Compiler Setup</A><BR>
</p></td>
  </tr>
</table>
<TABLE BORDER="0" CELLPADDING="10" CELLSPACING="0" WIDTH="100%"><TR><TD><p><BR>
</p>
  </TD></TR></TABLE>

</BODY>
</HTML>